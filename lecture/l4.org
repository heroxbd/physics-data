#+TITLE: 数组

* 文档
** 注释
   注释由半角的“#”引出，多行注释用多个“#”：
   #+NAME: 70e65a46-9e12-4c4d-b122-dc42590a25ae
   #+begin_src ein-python :results output :session https://dpcg.g.airelinux.org/user/xubd/lecture-python.ipynb
    # 高精度整数举例
    #
    2**1000
   #+end_src

   #+RESULTS: 70e65a46-9e12-4c4d-b122-dc42590a25ae
   : 10715086071862673209484250490600018105614048117055336074437503883703510511249361224931983788156958581275946729175531468251871452856923140435984577574698574803934567774824230985421074605062371141877954182153046474983581941267398767559165543946077062914571196477686542167660429831652624386837205668069376

   要让程序易于被人理解，一方面应提升和打磨代码风格，让程序本身的逻辑易懂，另一方面，对不明显的程序段落，通过注释来解释。
** 函数的文档
   函数是代码复用的单元，这意味着我们经常会用到别人创作的函数，以节省精力，站在巨人或者一群小矮人的肩膀上。函数定义后紧接的字符串是它的文档，它被特殊对待，由 =help()= 读取输出：
   #+NAME: d28f616f-8011-4581-b76f-2a4e1201ff8e
   #+begin_src ein-python :results output :session https://dpcg.g.airelinux.org/user/xubd/lecture-python.ipynb
     def spherical_harmonic_fitter(grid, order):
         "求球谐函数拟合的系数"
    
         # 具体实现省略
         pass

     help(spherical_harmonic_fitter)
   #+end_src

   #+RESULTS: d28f616f-8011-4581-b76f-2a4e1201ff8e
   : Help on function spherical_harmonic_fitter in module __main__:
   : 
   : spherical_harmonic_fitter(grid, order)
   :     求球谐函数拟合的系数
   : 
   帮助告诉我们，在 “__main__” 模块（程序默认环境）的名字空间里，有这个函数。

   一行的帮助有些单薄。函数的文档，由他人使用，文档写得越详细越好。对复杂的函数而言，函数的帮助需要长篇大论。Python 的多行字符串，正好胜任这一点。多行字符串以三个引号开始，三个引号结束，单引号双引号皆可。三引号设计恰好不与人类语言冲突。
   #+NAME: 1a8eb1cc-c051-47f1-b3cf-142b12da0378
   #+begin_src ein-python :results output :session https://dpcg.g.airelinux.org/user/xubd/lecture-python.ipynb
     def spherical_harmonic_fitter(grid, order):
         '''
         求球谐函数拟合的系数
    
         输入
         ~~~
         grid: 球面上连续函数在固定格点上的取值
         order: 拟合时球谐函数近似截断的阶数
    
         输出
         ~~~
         拟合系数矩阵
         '''
    
         # 具体实现省略
         pass

     help(spherical_harmonic_fitter)
   #+end_src

   #+RESULTS: 1a8eb1cc-c051-47f1-b3cf-142b12da0378
   #+begin_example
   Help on function spherical_harmonic_fitter in module __main__:

   spherical_harmonic_fitter(grid, order)
       求球谐函数拟合的系数

       输入
       ~~~
       grid: 球面上连续函数在固定格点上的取值
       order: 拟合时球谐函数近似截断的阶数

       输出
       ~~~
       拟合系数矩阵

   #+end_example
   这个例子里，我们把文档写得更加详细。不仅有标题，还详细注明了输入和输出的含义。调用函数的人——可能是队友也可能是未来的自己——应当在不阅读的原代码的前提下，顺利使用它们。即使在写作程序时，感觉很显然，也应该认真撰写文档。在例子中，我们用多行字符串写出，函数在固定格点上取值，定义了输入变量 order 的含义，输出的意义是系统。
** 标准库中的文档
   Python 的标准库非常重视文档，几乎所有的函数都带有详细的排版精美的多行字符串说明。
   #+NAME: ee4df6b1-62ca-42c5-8306-22f8d088f66a
   #+begin_src ein-python :results output :session https://dpcg.g.airelinux.org/user/xubd/lecture-python.ipynb
     help(int)
   #+end_src

   #+RESULTS: ee4df6b1-62ca-42c5-8306-22f8d088f66a
   #+begin_example
   Help on class int in module builtins:

   class int(object)
    |  int([x]) -> integer
    |  int(x, base=10) -> integer
    |  
    |  Convert a number or string to an integer, or return 0 if no arguments
    |  are given.  If x is a number, return x.__int__().  For floating point
    |  numbers, this truncates towards zero.
    |  
    |  If x is not a number or if base is given, then x must be a string,
    |  bytes, or bytearray instance representing an integer literal in the
    |  given base.  The literal can be preceded by '+' or '-' and be surrounded
    |  by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
    |  Base 0 means to interpret the base from the string as an integer literal.
    |  >>> int('0b100', base=0)
    |  4
    |  
    |  Built-in subclasses:
    |      bool
    |  
    |  Methods defined here:
    |  
    |  __abs__(self, /)
    |      abs(self)
    |  
    |  __add__(self, value, /)
    |      Return self+value.
    |  
    |  __and__(self, value, /)
    |      Return self&value.
    |  
    |  __bool__(self, /)
    |      self != 0
    |  
    |  __ceil__(...)
    |      Ceiling of an Integral returns itself.
    |  
    |  __divmod__(self, value, /)
    |      Return divmod(self, value).
    |  
    |  __eq__(self, value, /)
    |      Return self==value.
    |  
    |  __float__(self, /)
    |      float(self)
    |  
    |  __floor__(...)
    |      Flooring an Integral returns itself.
    |  
    |  __floordiv__(self, value, /)
    |      Return self//value.
    |  
    |  __format__(self, format_spec, /)
    |      Default object formatter.
    |  
    |  __ge__(self, value, /)
    |      Return self>=value.
    |  
    |  __getattribute__(self, name, /)
    |      Return getattr(self, name).
    |  
    |  __getnewargs__(self, /)
    |  
    |  __gt__(self, value, /)
    |      Return self>value.
    |  
    |  __hash__(self, /)
    |      Return hash(self).
    |  
    |  __index__(self, /)
    |      Return self converted to an integer, if self is suitable for use as an index into a list.
    |  
    |  __int__(self, /)
    |      int(self)
    |  
    |  __invert__(self, /)
    |      ~self
    |  
    |  __le__(self, value, /)
    |      Return self<=value.
    |  
    |  __lshift__(self, value, /)
    |      Return self<<value.
    |  
    |  __lt__(self, value, /)
    |      Return self<value.
    |  
    |  __mod__(self, value, /)
    |      Return self%value.
    |  
    |  __mul__(self, value, /)
    |      Return self*value.
    |  
    |  __ne__(self, value, /)
    |      Return self!=value.
    |  
    |  __neg__(self, /)
    |      -self
    |  
    |  __or__(self, value, /)
    |      Return self|value.
    |  
    |  __pos__(self, /)
    |      +self
    |  
    |  __pow__(self, value, mod=None, /)
    |      Return pow(self, value, mod).
    |  
    |  __radd__(self, value, /)
    |      Return value+self.
    |  
    |  __rand__(self, value, /)
    |      Return value&self.
    |  
    |  __rdivmod__(self, value, /)
    |      Return divmod(value, self).
    |  
    |  __repr__(self, /)
    |      Return repr(self).
    |  
    |  __rfloordiv__(self, value, /)
    |      Return value//self.
    |  
    |  __rlshift__(self, value, /)
    |      Return value<<self.
    |  
    |  __rmod__(self, value, /)
    |      Return value%self.
    |  
    |  __rmul__(self, value, /)
    |      Return value*self.
    |  
    |  __ror__(self, value, /)
    |      Return value|self.
    |  
    |  __round__(...)
    |      Rounding an Integral returns itself.
    |      Rounding with an ndigits argument also returns an integer.
    |  
    |  __rpow__(self, value, mod=None, /)
    |      Return pow(value, self, mod).
    |  
    |  __rrshift__(self, value, /)
    |      Return value>>self.
    |  
    |  __rshift__(self, value, /)
    |      Return self>>value.
    |  
    |  __rsub__(self, value, /)
    |      Return value-self.
    |  
    |  __rtruediv__(self, value, /)
    |      Return value/self.
    |  
    |  __rxor__(self, value, /)
    |      Return value^self.
    |  
    |  __sizeof__(self, /)
    |      Returns size in memory, in bytes.
    |  
    |  __sub__(self, value, /)
    |      Return self-value.
    |  
    |  __truediv__(self, value, /)
    |      Return self/value.
    |  
    |  __trunc__(...)
    |      Truncating an Integral returns itself.
    |  
    |  __xor__(self, value, /)
    |      Return self^value.
    |  
    |  as_integer_ratio(self, /)
    |      Return integer ratio.
    |      
    |      Return a pair of integers, whose ratio is exactly equal to the original int
    |      and with a positive denominator.
    |      
    |      >>> (10).as_integer_ratio()
    |      (10, 1)
    |      >>> (-10).as_integer_ratio()
    |      (-10, 1)
    |      >>> (0).as_integer_ratio()
    |      (0, 1)
    |  
    |  bit_length(self, /)
    |      Number of bits necessary to represent self in binary.
    |      
    |      >>> bin(37)
    |      '0b100101'
    |      >>> (37).bit_length()
    |      6
    |  
    |  conjugate(...)
    |      Returns self, the complex conjugate of any int.
    |  
    |  to_bytes(self, /, length, byteorder, *, signed=False)
    |      Return an array of bytes representing an integer.
    |      
    |      length
    |        Length of bytes object to use.  An OverflowError is raised if the
    |        integer is not representable with the given number of bytes.
    |      byteorder
    |        The byte order used to represent the integer.  If byteorder is 'big',
    |        the most significant byte is at the beginning of the byte array.  If
    |        byteorder is 'little', the most significant byte is at the end of the
    |        byte array.  To request the native byte order of the host system, use
    |        `sys.byteorder' as the byte order value.
    |      signed
    |        Determines whether two's complement is used to represent the integer.
    |        If signed is False and a negative integer is given, an OverflowError
    |        is raised.
    |  
    |  ----------------------------------------------------------------------
    |  Class methods defined here:
    |  
    |  from_bytes(bytes, byteorder, *, signed=False) from builtins.type
    |      Return the integer represented by the given array of bytes.
    |      
    |      bytes
    |        Holds the array of bytes to convert.  The argument must either
    |        support the buffer protocol or be an iterable object producing bytes.
    |        Bytes and bytearray are examples of built-in objects that support the
    |        buffer protocol.
    |      byteorder
    |        The byte order used to represent the integer.  If byteorder is 'big',
    |        the most significant byte is at the beginning of the byte array.  If
    |        byteorder is 'little', the most significant byte is at the end of the
    |        byte array.  To request the native byte order of the host system, use
    |        `sys.byteorder' as the byte order value.
    |      signed
    |        Indicates whether two's complement is used to represent the integer.
    |  
    |  ----------------------------------------------------------------------
    |  Static methods defined here:
    |  
    |  __new__(*args, **kwargs) from builtins.type
    |      Create and return a new object.  See help(type) for accurate signature.
    |  
    |  ----------------------------------------------------------------------
    |  Data descriptors defined here:
    |  
    |  denominator
    |      the denominator of a rational number in lowest terms
    |  
    |  imag
    |      the imaginary part of a complex number
    |  
    |  numerator
    |      the numerator of a rational number in lowest terms
    |  
    |  real
    |      the real part of a complex number

   #+end_example

   Python 的[[https://docs.python.org/3/][文档网站]]的内容，就是由这些代码中的函数文档生成。这种把人类可读和机器可读的文字写在一起的思想，叫做“literate programming”，目标是让程序既适合被机器执行，也适合被人类阅读。修改程序与修改文档要保持同步。相反，如果程序与文档写在不同地方，甚至由不同的人来撰写，那么大概率经年累月，它们会有很大出入，使用文档失去了应有的价值。因此从一开始贯彻 literate programming 的原则，有助于长远的程序可读性和易用性，注意体会其中的“一次”原则：文档和程序在说同一件事情，我们只在一个地方把它们全都写出来。
   在通过书籍或课程系统性地对 Python 语言和环境的整形把握之后， 随手查阅 =help()= 所得的在线帮助非常实用，是灵活的“工具书”。我们有了基础之后，可以借助这个强大的帮助系统边学边用，学习和工作效率都会很高。

* Python 模块
  Python 的模块是把函数等聚集起来的名字空间，由目录或者文件划定。它既可以由 Python 实现，也可以由 C 和 Fortran 等编译语言实现。半个多世纪积累下来的优秀程序，大多可以以 Python 模块的形式出现，被复用，实践“一次”原则。
  Python 的模块都具有详实的在线帮助。
  #+NAME: 58fb5fcf-35e8-4e0c-9728-79e4f0d0c4bc
  #+begin_src ein-python :results output :session https://dpcg.g.airelinux.org/user/xubd/lecture-python.ipynb
    import math
    help(math)
  #+end_src

  #+RESULTS: 58fb5fcf-35e8-4e0c-9728-79e4f0d0c4bc
  #+begin_example
  Help on module math:

  NAME
      math

  MODULE REFERENCE
      https://docs.python.org/3.9/library/math

      The following documentation is automatically generated from the Python
      source files.  It may be incomplete, incorrect or include features that
      are considered implementation detail and may vary between Python
      implementations.  When in doubt, consult the module reference at the
      location listed above.

  DESCRIPTION
      This module provides access to the mathematical functions
      defined by the C standard.

  FUNCTIONS
      acos(x, /)
          Return the arc cosine (measured in radians) of x.

          The result is between 0 and pi.

      acosh(x, /)
          Return the inverse hyperbolic cosine of x.

      asin(x, /)
          Return the arc sine (measured in radians) of x.

          The result is between -pi/2 and pi/2.

      asinh(x, /)
          Return the inverse hyperbolic sine of x.

      atan(x, /)
          Return the arc tangent (measured in radians) of x.

          The result is between -pi/2 and pi/2.

      atan2(y, x, /)
          Return the arc tangent (measured in radians) of y/x.

          Unlike atan(y/x), the signs of both x and y are considered.

      atanh(x, /)
          Return the inverse hyperbolic tangent of x.

      ceil(x, /)
          Return the ceiling of x as an Integral.

          This is the smallest integer >= x.

      comb(n, k, /)
          Number of ways to choose k items from n items without repetition and without order.

          Evaluates to n! / (k! * (n - k)!) when k <= n and evaluates
          to zero when k > n.

          Also called the binomial coefficient because it is equivalent
          to the coefficient of k-th term in polynomial expansion of the
          expression (1 + x)**n.

          Raises TypeError if either of the arguments are not integers.
          Raises ValueError if either of the arguments are negative.

      copysign(x, y, /)
          Return a float with the magnitude (absolute value) of x but the sign of y.

          On platforms that support signed zeros, copysign(1.0, -0.0)
          returns -1.0.

      cos(x, /)
          Return the cosine of x (measured in radians).

      cosh(x, /)
          Return the hyperbolic cosine of x.

      degrees(x, /)
          Convert angle x from radians to degrees.

      dist(p, q, /)
          Return the Euclidean distance between two points p and q.

          The points should be specified as sequences (or iterables) of
          coordinates.  Both inputs must have the same dimension.

          Roughly equivalent to:
              sqrt(sum((px - qx) ** 2.0 for px, qx in zip(p, q)))

      erf(x, /)
          Error function at x.

      erfc(x, /)
          Complementary error function at x.

      exp(x, /)
          Return e raised to the power of x.

      expm1(x, /)
          Return exp(x)-1.

          This function avoids the loss of precision involved in the direct evaluation of exp(x)-1 for small x.

      fabs(x, /)
          Return the absolute value of the float x.

      factorial(x, /)
          Find x!.

          Raise a ValueError if x is negative or non-integral.

      floor(x, /)
          Return the floor of x as an Integral.

          This is the largest integer <= x.

      fmod(x, y, /)
          Return fmod(x, y), according to platform C.

          x % y may differ.

      frexp(x, /)
          Return the mantissa and exponent of x, as pair (m, e).

          m is a float and e is an int, such that x = m * 2.**e.
          If x is 0, m and e are both 0.  Else 0.5 <= abs(m) < 1.0.

      fsum(seq, /)
          Return an accurate floating point sum of values in the iterable seq.

          Assumes IEEE-754 floating point arithmetic.

      gamma(x, /)
          Gamma function at x.

      gcd(*integers)
          Greatest Common Divisor.

      hypot(...)
          hypot(*coordinates) -> value

          Multidimensional Euclidean distance from the origin to a point.

          Roughly equivalent to:
              sqrt(sum(x**2 for x in coordinates))

          For a two dimensional point (x, y), gives the hypotenuse
          using the Pythagorean theorem:  sqrt(x*x + y*y).

          For example, the hypotenuse of a 3/4/5 right triangle is:

              >>> hypot(3.0, 4.0)
              5.0

      isclose(a, b, *, rel_tol=1e-09, abs_tol=0.0)
          Determine whether two floating point numbers are close in value.

            rel_tol
              maximum difference for being considered "close", relative to the
              magnitude of the input values
            abs_tol
              maximum difference for being considered "close", regardless of the
              magnitude of the input values

          Return True if a is close in value to b, and False otherwise.

          For the values to be considered close, the difference between them
          must be smaller than at least one of the tolerances.

          -inf, inf and NaN behave similarly to the IEEE 754 Standard.  That
          is, NaN is not close to anything, even itself.  inf and -inf are
          only close to themselves.

      isfinite(x, /)
          Return True if x is neither an infinity nor a NaN, and False otherwise.

      isinf(x, /)
          Return True if x is a positive or negative infinity, and False otherwise.

      isnan(x, /)
          Return True if x is a NaN (not a number), and False otherwise.

      isqrt(n, /)
          Return the integer part of the square root of the input.

      lcm(*integers)
          Least Common Multiple.

      ldexp(x, i, /)
          Return x * (2**i).

          This is essentially the inverse of frexp().

      lgamma(x, /)
          Natural logarithm of absolute value of Gamma function at x.

      log(...)
          log(x, [base=math.e])
          Return the logarithm of x to the given base.

          If the base not specified, returns the natural logarithm (base e) of x.

      log10(x, /)
          Return the base 10 logarithm of x.

      log1p(x, /)
          Return the natural logarithm of 1+x (base e).

          The result is computed in a way which is accurate for x near zero.

      log2(x, /)
          Return the base 2 logarithm of x.

      modf(x, /)
          Return the fractional and integer parts of x.

          Both results carry the sign of x and are floats.

      nextafter(x, y, /)
          Return the next floating-point value after x towards y.

      perm(n, k=None, /)
          Number of ways to choose k items from n items without repetition and with order.

          Evaluates to n! / (n - k)! when k <= n and evaluates
          to zero when k > n.

          If k is not specified or is None, then k defaults to n
          and the function returns n!.

          Raises TypeError if either of the arguments are not integers.
          Raises ValueError if either of the arguments are negative.

      pow(x, y, /)
          Return x**y (x to the power of y).

      prod(iterable, /, *, start=1)
          Calculate the product of all the elements in the input iterable.

          The default start value for the product is 1.

          When the iterable is empty, return the start value.  This function is
          intended specifically for use with numeric values and may reject
          non-numeric types.

      radians(x, /)
          Convert angle x from degrees to radians.

      remainder(x, y, /)
          Difference between x and the closest integer multiple of y.

          Return x - n*y where n*y is the closest integer multiple of y.
          In the case where x is exactly halfway between two multiples of
          y, the nearest even value of n is used. The result is always exact.

      sin(x, /)
          Return the sine of x (measured in radians).

      sinh(x, /)
          Return the hyperbolic sine of x.

      sqrt(x, /)
          Return the square root of x.

      tan(x, /)
          Return the tangent of x (measured in radians).

      tanh(x, /)
          Return the hyperbolic tangent of x.

      trunc(x, /)
          Truncates the Real x to the nearest Integral toward 0.

          Uses the __trunc__ magic method.

      ulp(x, /)
          Return the value of the least significant bit of the float x.

  DATA
      e = 2.718281828459045
      inf = inf
      nan = nan
      pi = 3.141592653589793
      tau = 6.283185307179586

  FILE
      /usr/lib/python3.9/lib-dynload/math.cpython-39-x86_64-linux-gnu.so


  #+end_example
  在 REPL 环境中，我们还可以输入 =math.= 后，按 TAB 建来给出后面可能接的函数，非常有助于去探索一个新的模块。看到不明白含义的 TAB 提示，配合 =help= 即可迅速掌握。
  #+NAME: 88887ff3-44c4-42b0-86ba-e8f1836ef1ca
  #+begin_src ein-python :results output :session https://dpcg.g.airelinux.org/user/xubd/lecture-python.ipynb
    help(math.gcd)
  #+end_src

  #+RESULTS: 88887ff3-44c4-42b0-86ba-e8f1836ef1ca
  : Help on built-in function gcd in module math:
  : 
  : gcd(*integers)
  :     Greatest Common Divisor.
  : 
  可发现性，是 Python 易于入门的重要特征。

  装载模块时，能够自定义名称，缩短程序的长度来增强可读性。
  #+NAME: e3030744-e26c-4ce4-9589-aecbaad062e3
  #+begin_src ein-python :results output :session https://dpcg.g.airelinux.org/user/xubd/lecture-python.ipynb
    import math as m
    m.factorial(10)
  #+end_src

  #+RESULTS: e3030744-e26c-4ce4-9589-aecbaad062e3
  : 3628800

** 多层模块的加载
   当模块中的内容很多时，会被安排在不同层次的名字空间中。有多种等价的方法访问它们：
   #+NAME: a6e8d710-386b-404c-be93-34df4fc4643f
   #+begin_src ein-python :results output :session https://dpcg.g.airelinux.org/user/xubd/lecture-python.ipynb
     import os
     from os.path import abspath
     from os.path import abspath as absp
     abspath is os.path.abspath, abspath is absp
   #+end_src

   #+RESULTS: a6e8d710-386b-404c-be93-34df4fc4643f
   : (True, True)
   =os.path.abspath= 是 os 模块的 path 子模块中返回绝对路径的函数。直接使用很啰嗦，配合 =from= 会简洁很多。

* 程序的测试
  在撰写较长较复杂的程序时，我最关心的问题是，到底如何保证程序正确呢？眼睛一直盯着它，多看几遍就对了吗？不是。
  另一个相关的问题是，我已经写出一个正确的程序，但我修改完善它，如果保证从改动前后程序的逻辑不变呢？否则，如果一不小心改坏就闯祸了，还不如不完善。如何快速确认完善后的程序是好的？
  一个程序的中间结果应该当被人理解，是“透明”原则的要求，可以通过调试来确保程序的正确性。但是问题远没有这么简单，如果我们 _每次_ 都使用程序调试方法如 =print= =breakpoint= 等检查中间结果，势必会让保证程序正确性的工作变得重复乏味，成为自己的负担。
  “一次”原则应用到这里，要求我们写一个自动的测试程序，判断主程序的正确性。每次主程序有修改，都自动运行测试程序，确认原有功能是否正确。有时甚至我们在写主程序之前，应当先把测试程序写好，给定特定的输入输出，用测试程序来定义主程序的功能。当主程序需要填加新功能时，也是首先扩展测试程序，再写主程序。这种开发的方式，叫做“测试驱动的研发”。在团队分工中，可以一个人写测试程序，另一个人写主程序，实现分工。
  测试分为单元测试，用于确保某个函数的正确性，以及集成测试，用于保证程序总体（特别是各函数之间的接口）达到设计要求。研发的过程中，测试与主程序相辅相成，相互依赖着前进。
  自动测试是有效避免“祖传代码”的途径。“祖传代码”意为一个长久使用但疏于维护的程序，因为依赖旧环境执行，兼容性极差。但是没有人敢于完善它，因为修改使程序损坏的代价远高于兼容性差带来的不便，随着时间的推移，程序变得越来越不好用，也越来越不可能被修改。破局的关键是测试程序，首先要通过测试来定义清楚，什么样的结果是“改得好”，什么样是“改坏了”。随后的主体完善就有了客观标准，得以顺利进行。测试和主程序像两条腿，交替前进。缺少了测试程序，一条腿无法走路，才变成了“祖传程序”。

* 数组
  数组由 Python 的 NumPy 模块定义，含义为“numerical Python”，即 Python 数值计算工具。NumPy 起源于使用 Python 调用 Fortran 进行线性代数计算。历史上 Fortran 是最早的计算机高级语言，是编写数值计算程序的首选。几十年间，Fortran 积累了大量优质的数值计算工具库。Python 被用于科学计算时，最重要的是能无缝调用已有的 Fortran 程序，在巨人的肩膀上前进。
  NumPy 从 Fortran 的调用接口开始发展，逐步研发更高级的功能，成为了 Python 科学计算的基础，是 Python 上数值计算的“最佳工具”。所有的 Python 科学计算工具库都沿用了 NumPy 的数据结构定义。
  NumPy 还不是 Python 的标准库，需要使用
  #+begin_src ein-bash :results output :session https://dpcg.g.airelinux.org/user/xubd/lecture.ipynb
    apt install python3-numpy
  #+end_src
  来安装。

** 创建数组
   #+NAME: 3be6411c-26d3-44e7-8316-3e75a3559aaf
   #+begin_src ein-python :results output :session https://dpcg.g.airelinux.org/user/xubd/lecture-python.ipynb
     import numpy as np

     nv = np.array([1,2,3,4,3,2,1])
     print(nv)
   #+end_src

   #+RESULTS: 3be6411c-26d3-44e7-8316-3e75a3559aaf
   : [1 2 3 4 3 2 1]
   =np= 是约定的 =numpy= 缩写。第一次用 =np.array= ，可以用 =help= 来查看文档学习用法。给 =np.array= 放进列表，返一个创建数组赋予 =nv= 。数组的内容确认与列表一样。

** 列表与数组的区别
   自然的疑问是：既然数组与列表的内容相同，为何还要增加新的数据类型？数组要求其元素的数据类型一致，如果给了不一致的元素，元素会退化成 =object= 类型，失去大多数运算功能。
   #+NAME: 60f76fe2-d29d-4fd1-acf2-a32d815b35cd
   #+begin_src ein-python :results output :session https://dpcg.g.airelinux.org/user/xubd/lecture-python.ipynb
     print(nv.dtype)

     print(np.array([1, "a", None]).dtype)
   #+end_src

   #+RESULTS: 60f76fe2-d29d-4fd1-acf2-a32d815b35cd
   : int64
   : object
   数据类型一致的限制，换取的是数组所占空间可预测的好处。这使得它可以在计算机内存中连续存储，不仅有更高的读写效率，还可以表达更高维的结构。列表由动态链表实现，灵活但是损失了效率。
** 数组的索引
   数组的索引与列表有同样的基础语法，例如：
   #+NAME: 0ffdd86e-3b89-4081-942c-f45866ba2527
   #+begin_src ein-python :results output :session https://dpcg.g.airelinux.org/user/xubd/lecture-python.ipynb
     nv[2], nv[5:], nv[-1]
   #+end_src

   #+RESULTS: 0ffdd86e-3b89-4081-942c-f45866ba2527
   : (3, array([2, 1]), 1)

它没有办法
通过一个类型来反映
在元素里面所有类型
所以它变成了一个
最抽象的最一般的类型
那么这个类型
其实没有太大的
用途 就是
体现不出来数组的优势
而且我们在使用它的时候
一般来说需要把
 object
转化成相应的类型
那么第二点
数组的存储它是
占用一段连续的空间
但列表一般来说不是的
我们占用一段连续的内存空间
我们就可以对它进行一些
很优化的操作
因为我们可以假设
这个数组里边的元素是紧挨着的
那么如果有这样的假设
在计算机内部运行的时候
如果是使用速度
比如说内存的读取
数据的交换
就会更加的有效率
所以基于以上两点
使得在这个数值计算中
数组的效率会比这个普通的列表
要高很多
一方面的效率是
它的有数据类型是被定义的
另一方面的效率
是它在内存里面的
内部的存储方式不一样
所以说当我们要遇到一个
规模比较大的问题的时候
把列表转换成数字
会有性能
会有比较大的提升
那么数组跟列表
其实它的索引方式都非常一样
刚才我已经
因为举这个例子
比如 0 1 2
我们回头用一个比较常用的数据
刚才我们打的是
我们刚才就定义这个变量是nv
那么我们看nv[0]就是
第一个元素
之前
对这个列表
有各种各样的操作
比如说这个是从
第二个元素开始
去取这个内容
我们看它依旧是一个数组
比如说
我每隔一个
这个
我每隔一个再取一个
这是我们应该是第一次遇到的
就是说
默认的来讲
我们取整个的数组
都是一个一个取
那么这个2就是每两个取
对
我们看把其中的奇数数部分取出来
那么想如果我
每-1个取一个
会是什么样的状况呢
那么它就是把这个数组
倒过来
我这个例子不好
正过来倒过来差不多
但是我们看到
我这个例子是开始
是1结尾是2
它其实开始是2 结尾是1
我们来找一个更好的例子
我们用arange
我们用的range
arange是
numpy里边的range
它可以直接生成一个数组
比如说arange(10)
可以把它叫做ar
然后看ar
它就是arange生成的
从0~9
如果我对它进行每走-1
取一个数的话
那么它就这样倒了过来
这是一些常用的操作
那么二维数组
其实可以来用来表示矩阵
二维数组其实
并没有太多本质上的区别
比如数组默认来说是一维的
那么二维的也就是说
先把行写完
然后再按列写
那么以此类推
n维的数组
那就可以是第一个维度先写完
然后再写第二个维度
再第三个维度
相信同学们
在学线性代数的时候
或者高等代数的时候
都有很深的体会
比如说我们
来做一个二维的数据
这里边我做了一个单位阵
比如说单位矩阵
单位矩阵要怎么写呢
numpy.array
二维数组
所以就有两个维度
两个维度用
用这个列表来写
那么这个维度内是它的行
维度外是它的列
我们来仔细看一下
如果我要写一个这样
二维的单位阵的话
先把这个行写出来
看一下
先把行写出来
第一行是10
那么我就这样写一个列表
[1, 0]这样写出来
第二行是[0, 1]
然后这两个行
我们再把它看成一个单元
再组成一个列表
这样就是两个列
我们来实际的写一下
比如说
numpy.array
现在就是列
然后往里面添行
第一行是[1, 0]
第二行是[0, 1]
这样的一个二维数组
创造出来了
它叫m matrix
它就是单位矩阵
matrix取下标的时候
我们二维的数组
所以就有
二维的下标
这个下标
我们也可以先取
这样
先取第一维
然后再取第二维
这样写
把它当做是
两层的一维数组
那么简写我们可以这样写
就先写
先写第一维
然后再写第二维
它是一样的
我们看一下是不是一样的
不是一样的
那我们来试一下
然后
可能是遇到了我知识的盲区
我们把它改成3
好
看起来这个经过版本更新
它的内部存储有一些改变
但是我们可以通过等号来判断
它可能不完全是一样的
等号判断是可以的
那么在这个矩阵里边
我们可以看矩阵的类型
比如说我们看
刚才我们造这个单位阵
这个类型是说叫做
numpy.ndarray
n dimensional array 的
缩写
那么m它还有一个比较重要的
参数是它的shape
是
代表它是2×2的一个矩阵
那么数组我们刚才看到
要把它创建起来
特别是二维的时候
其实挺麻烦的
我们要想它行是什么
然后把行里边的数据都给写出来
然后再写第二行
再写第三行
这种写法
还是很繁琐的
有很多常用的
数组 numpy里边
它默认给出来的
比如说
所有都是1的数组啊
所有都是0的数组
都可以给出来
比如说我们
然后来试验一下
我来打 np.ones
所有为1的数据就是说
3×4的矩阵
这里是需要一个
需要是一个列表
或者是 tuple
我看这是三行四列的矩阵
里边都堆满了1
那么如果是zeros
这里边就堆满了0
那么单位阵叫eye
因为单位阵都是方的
所以说不需要写两个参数
这是
5维的
就是这个样子
我们可以看一下eye的帮助
返回一个二维的
二维的数组
它符合单位阵的定义
它默认只要一个参数就行了
其他的时候
还有一些其他的参数
同学们可以有兴趣
可以仔细实验一下
比如说它可以这样定义整型的
单位这样
也可以让k=1变成了一个
上三角矩阵
这些都可以
看来默认是k=0
k=0的时候是
这个参数k=0的时候
它是一个单位阵
k=2
它就变成了
距离对角线有两个单位
这样的一个上三角矩阵
这样的功能还有非常的丰富
同学们可以在这里
比如说np. tab
发现有这么多
有这么多函数
这么多
还有
还有
我们可以一点点
大家可能看到感兴趣的
对
可以来
仔细看一下它的帮助文档
对于我来说
其实我也不知道
这里面所有的定义
一般来说是用到的时候
想一下
如果我是numpy的作者
我会不会实现这样的函数呢
如果大概率会
我就在这里找一下
一般来说是能找到的
旁边就是
我们看刚才我介绍了
我又提前介绍
那么arange
之前我们循环的时候
使用的range的一个
numpy的对应物
arange
如果是这个样子的话
我可以对它
这样进行倒过来
然后也可以进行
隔一个
取一个这样的
那么隔两个取一个就是3
就是每次会跳三步
那么我就取出了3的倍数
如果这样就取出了2的倍数
如果这样的就取出了5的倍数
我看如果我们进行
 arange这样
取1000的话
发生了什么
我多打了一个r
那取1000的话就有1000个
我们看一下
所有17的倍数是什么样的
一个是17
我们看17 34 51 68
用我们心算一下
然后发现都是17的倍数
然后
肯定是没问题的
那么还有一些更复杂的索引方法
也就是说numpy它的基本功能
就是大家能够让
把很多的数字
用这个一定的规律
组成各种各样的方阵
或者是二维的方阵
三维的方阵
多维的方阵
然后以各种各样的方式
来变换方阵
以及方阵之间的运算
这就是numpy的基本功能
我们想象一下
如果这些数
让我们自己来做的话
其实还是很繁琐的一些功能
比如说现在这个图
是我从我们的参考资料
就是我们第二个参考书
上面拿到的这个图
给了我们一个这样的例子
比如说这个图是一个
6×6
6×6的这样一个二维数组
那么每个开头
每一行开头
它都是行数
比如说是0~50
然后每一列
都是它的个位数0~5
那么这样六维数组
我们看
如果对它进行索引
从a 0 那就是第0行
那么3~5
3~5那我要记得这是左闭右开的
区间
那么3~5
就是取到了这两个元素
那么[4:, 4:]
第4个
第4行开始要从第4页开始
我们从这边数
第4个就是这样
从第4行开始
也就是这段部分
第4列开始
所以[4:, 4:]就取了方阵的右下角
注意后面冒号表示是从
4开始
那么单独一个冒号
它意味着是说
把整个的维度全取下来
比如说
这样2
那也就是说
取所有行
但是每一行里边
都只取
第三列
我们已经看到了
人类语言跟计算机语言的区别
发生了什么
太可怕了
我们看到[:, 2]代表的是第三列
要注意
因为是从0开始数数
对不对
大家可以试验一下
一会儿我们来试验一下
那么还有一个是
比如说2
这个行数是从2开始
每隔一行会再取一行
就是每数两个数取一个
那么从2开始
从第3行开始
那么隔一个取一个
那么恰好是取了
这一行
或者这一行
我还是使用计算机的函数
我就把它叫做第2列
这个叫做第0列
要不然
我必须得来回转换
我觉得肯定会说错的
我看列也是从
第0列开始
每两个取
那么从第0列到第2列到第4列
然后就取下来
我看一共有6个数
这6个数就拿到了
这个是numpy最强大的地方
我们来做一个练习
比如说我们arange(100)
把这个叫做s
它是一个从0~99的
然后我们把它转换成
二维数组
我们把它的shape
我们看一下
现在它的shape是100
也就是说它是一维数组
比较容易
我们应该可以通过改shape
把它变成一个二维数组
让它变成10和10
看一下是否能够成功
然后是成功的
我慢一点
刚才我们用了arange
这样就得到了一个
从0~99的
这样一个数组
然后下一步我看了一下数组的
形状
这个形状叫做100
它的意思就是说
它是有100个元素的一维数据
然后我改善它的形状
我让它的形状变成
10和10
变成一个10×10的二维数组
你看一下
看它变成了一个二维数组
排的非常的整齐
非常的喜欢
那么s 我们可以

  我们可以试一下
刚才所学到的东西
比如说我取
把所有行都取过来
但是我只取第0列
我们看
确实是第0列
0 10 20 30 40 50
它取下来变成了一个数组
比如说我可以说
在这一行
行上呢只取3
那么这个行只是3的倍数
才可以
然后列只能是5的倍数
嗯我看一下
那么它就得到了
第0行
第3行
第6行
第9行
然后列就只有第0列和第5列
那么比如说
我希望把列给它倒过来
这样
把这个列给它倒过来
我看到
我一共取了3的倍数的行比如说
第0 第3 第6 第9
然后所有的都是倒过来
这个操作
非常的强大
同学们多练习一下
好
我们暂时先下课
刚才下课的时候有同学
提了一个问题
这个问题还是非常本质
我再做一下刚才做过的操作
我最开始是生成了一个一维的
数组
一维数组有100个元素
就是从0数到99
然后看一下这个数组的
我看一下这个数组的形状
它是100个元素没什么问题
然后我做了一件事情
我做一件事情
我说它既然是100个元素的
我想要一个
二维的数组
我就把它直接变成了
让它的shape
强行的把这个的shape
摁成了
10×10
它就变成了一个二维数组
这件事情看起来
很奇怪
奇怪之处是在于
一般我们认为一个数组的shape应该
是一个描述性的东西
是吧
我们说这里有一个矩阵
我问这个矩阵有多少行多少列
那么这个矩阵已经存在了
我才能问它是多少号多少列
我如果有一个
有一个向量
我问这个向量是多少维的
那么这个向量也有了
我才能问它多少维的
那么为什么我可以强行说这个
向量
就是多少维的
然后它就变了
这看起来是一个很奇怪的问题
虽然说一开始
我们觉得这个操作挺方便的
但是仔细越想越觉得
比较困惑
那么我们
我们其实可以再做这几件事
比如说10还可以分成2和5
我们可以把它变成
三个方向的一个
一个立体的阵
就可以这样
然后它就变成了这个样子
比如说
每一行都是5个元素
然后一共分成
每一列都是5个元素分成两行
两行之后
它就形成了一个小的方阵
2×5的方阵
2×5的方阵
在另一个维度
在10个上排列
就变成了
这样的
这样的三维数组
看一下它的shape
这样三维的数组
这看起来比较神奇
这里边是有原因的
有没有同学已经猜到了它的原因
有没有同学猜到他的原因
它其实跟计算机内部的数据存储
是有关系的
比如说计算机内部内存
从内存来说
内存就是0地址啊能存一个数
1这个地址能存一个数
然后内存比如说有8G
大概80亿个
而80亿个这样的单位
能存80亿个数
这80亿个数
它所在的地址基本上就是从0
一直排到80亿
那么实际上
我们的内存 用这种眼光来看
它本质上就是一个一维的数组
那么我们怎么把二维的数组
放在天然的一维的里边
其实实现的方法
就是通过改这些索引
帮我改了一些索引
比如说
我们把它退回到二维的数组
二维数组
是这样的
我们本来就是个二维数组
有两个维度没有办法放到内存
里边
因为我们可以说
既然每一行
我每走一行
那么列都要过10个
那么我们可以让他
比如说它的行是row
我们可以让row乘以10加上列
列是column
比如说我们可以这样
让每一个行乘以10
加上一个column
这样它就变成了一维数组
是吧
然后一维数组
给它在进行整除再取余
它就会变成二维数组
如果用另一种方法
整除区域
说不定就变成三维数组
所以说本质上来讲
二维数组
从0~99
和刚才的一维数组
从0~99
100个元素的一维数组
它们在内存里面
在计算机内部的存储单元里面
都是一样的
都是从1数到100
数过来
那么只是说
对于存储的这一个100个元素
它的解释方式不一样
在这种解释方式下
我让它shape
是10×10的这种解释方式下
numpy就会约定
当这个地方
10个之后
相对于内存里面的绝对位置
它每次都会增长1
那么这一个索引
它每次增长1在内存里边
都增长10
只要做了约定
那么就拿到了一个二维数组
到内存空间的
类似一维数组的一一映射
所以说这是一个
这是一个实现起来的细节问题
但是这个细节问题
体现出来
一点
这一点也是
说明了
为什么我刚才说
上一节课讲的部分
是整个numpy的核心
那么整个numpy
又是python里面
科学计算的核心
所以这个部分是最核心的部分
那么也就是说
numpy它的所有实现
并没有什么特别的
本质的不一样
都还是用内存
它的非常巧妙的地方
是把内存
以不同的方式进行解释
只要不同方式进行解释
就可以变换出
千差万别的
这些多维的
高维的数组
我们看到在这种方法下
只要我们定义了
某一个索引加一
到底在内存里边
过多少的话
只要把它定义出来
那么根本不局限于
二维数组
甚至100维数据也都没问题
那么也就是说
也就是说在numpy里面
我们如果进行张量运算
都是没问题
希望大家能够理解到这一点
感谢同学提这个问题
这个问题非常的本质
大家有什么疑问吗
就这个解释
可以满意吗
好
我们复习一下
刚才的精华的部分
现在我们通过改
它的解释方式
把它解释成了一个二维数组
那么这个二维数组
我们可以从第一个维度
比如说隔两行
每两行取1行
然后第2列每3行取1行
这样我们看0 20 40 60 80
0 3 6 9
没问题
或者是我
每一列人能倒过来
这可以倒过来
或者我取
第二行
或者取第3列
对
第3列就是23
我们第5行第3列
那就53
那么第5行倒数第3列
还有什么样的操作来着
比如说从第二行开始
每3行
取一行
然后它的第3列
第3列到第5列
从2开始
所有10位数是除以3余2的
2 5 8
从3到5就是3到4
比如说这样的一些变化
我们看到这样一些变化
可以节省我们非常
可以非常大的
大量的节省时间
而对于我们来说
这是一种非常自然的思维方式
因为大家都学过了
高等代数和线性代数
对于矩阵来说
简直是我们的自然语言一样
所以说我们写起来
也会心里边非常的舒服
对于我们来说
这就是我们的自然语言
所以说可以看到
pyhton对于
它的实现方式和自然语言描述是
非常接近的
那么有了这些
有了这些非常漂亮的
这种索引方式
我们可以对数组进行运算
我只举几个非常简单的例子
比如说刚才我们
拿到的一直到100
拿过来
比如说
这样一个二维的速度
我想把所有的元素都取平方
然后这样直接这样取平方
这个看起来分辨率有点不是很好
但是我们也可以看到
每个元素都可以取的平方
想象一下
如果我们要写循环
来算的话
要怎么算
可能
循环可能要先循环每行
我来尝试写一下
但这样写会非常麻烦
然后在每列的每行里边
然后我让它平方
然后再让它不换行
输出一个空格
然后
每一行输完之后
再让它回车一下
换行
我们看到是如果按照循环来写
我就只能这么想
虽然我已经用了python的
循环的比较
比较自然的语法
首先我让二维数组里边
对于每个行进行循环
然后对于每个行内
要对于每个列进行循环
循环之后
对每个列举的元素
我都把它平方
平方之后
对于每个列
我都在后面打一个空格
这样把它能够分隔开
分割开之后
如果每一行循环完之后
我再让它再换个行
这样我就打出来
我想在这个过程中
其实我已经想了很多事情
才能把这几个字母写出来
如果对比
这样一个操作
可见numpy是
可以让线性代数的这些操作
变得非常的简洁
也非常符合我们的直觉
因为我们的直觉
说把矩阵元素的平方一下
而且它输出的又比较漂亮
你看这些
0 1 100
这都是对齐的
而对于我来说
而我打的
比较初始的代码还不对齐
那么看起来还比较难看
所以说
大家要体会这一点
要善于使用
目前的最佳的工具
那么numpy对于我们来说
进行矩阵运算
线性代数运算
就是说目前我们手里边
最佳的工具
这也是我们学习numpy的原因
然后刚才 s我们可以
让它都倒过来
倒过来之后
就是变成
从99往前数
数到0
比如说
我可以让这两个矩阵加起来
加起来都等于99
因为我先正过来
再倒过来再加起来
你看这个过程中
就跟一个
我们写的语句
就跟一个数的运算是一样
单个一个数的运算是一样的
同学们在使用的过程中
会越用越感到
这个部分是特别的方便
那么如果大家在理解了
内存的存储其实很多
通过看一些文档
看一些其他的操作
其实可以把numpy组合出来
非常非常高级
非常惊为天人的
简洁的程序
希望同学们能够有意识的探索
我们想一下
刚才我是这样写了两个循环
那么如果不写两个循环
写一个所谓的
用list
写一个压缩版的循环
其实也要这样写
这样写我们看到
在这样一个例子里面
一维的从0到10 从0到9
这样10个元素的数组
这样一个规模的问题来讲
我们看还是要多写好几个字母
对于我们这样的
学物理的
学物理的人来说
多写一个字母都是很不开心的
所以说能够少写就少写
当然注释要多一些
然后这些基本操作
其实加减乘除都可以
比如说刚才是加法
我可以做减法
我看做减法就减出了
很多的我的奇数
然后我们还可以做什么
做乘法
做乘法就比较
做乘法也可以
做除法也可以
做除法就很不容易看
我们还是做乘法
那么
不仅可以进行按位的运算
也可以
对这样的数组
进行总结性运算
什么是总结性运算
本来它有100个数
我希望把这100个数
汇集成一个数
都有什么汇集方法
比如说求一个平均数
0~99的平均数
0到99的平均数
就是49.5
然后求一个中位数
求一个中位数
中位数也是49.5
我们可以求和
求和4950
那么再加100
就是5050
这是一些
常见的总结性的运算
我们还可以这样
比如说
求和我让它
只求一个维度的和
那我们看一下求和的函数
有没有什么值得看的地方
我们看到第二个参数
非常的有戏
因为它叫axis 它是说
从哪一个方向来进行求和
然后 axes along which a sum is performed
到底在哪个方向
进行求和
我们就可以进行
比如说
对它求和 axis=0
这是在哪个方向进行的求和
axis是0 就是把0压缩掉了
把这个行都给压缩掉了
行都没有了
剩下的都是这些列相同的
列都被求和
是吧
这一点我在学习高等代数的时候
就经常转不过来
到底哪个是行
哪个是列
我不知道同学们
有没有跟我同样的感受
在大一的时候
我就经常转不过来
每次都试一下
比如说按
也会这样的求
求均值
也可以这样去解决
对均值来说肯定是
这样求了均值之后
肯定每两列之间都差一
因为对于每一行它都差1
每个元素都差异
是吧
同学们都跟上了吗
有没有什么疑问
如果是一个三维数据
会不会有变化
就三个axis
来我们试一下
给我们来个三维数组
三维数组
这样
这是一个4×4×4的数组
我们看
当然我的屏幕只是二维的
所以没办法显示出三维的东西
那么我们可以比如说对它的
axis=0
代表把第0维的维度
加起来
这样还剩两个维
是吧
然后把第一维的维度加起来
或者是把第二位的维度加起来
这样就我们可以想象
4x4x4
这有一个
有一个像魔方一样的
三维的数组啊
我们可以朝投影的方向
进行求和
或者朝投影方向进行
或者朝那个方向进行
我们应该也可以
对两个投影的方向进行求和
看一下可不可以这样
我也不确定可不可以
我猜是可以的
可以
比如说把第一个维度
4×4
都求和
把第二个维度都求和
不第一个第0个维度
我们看一下是不是
刚才的0和1求没了
两个维度求和
但具体是哪两个维度
我们想这有一个方块
是这两个维度
应该说
每次我想的时候
都需要仔细想一想
而且一想就会想错
一般的时候
我会多试一下
同学们如果有这样
线性空间的思考技巧
可以传授给我
我一直很困惑
经常说第几行
第几列还是第几列第几行
我就会把这个对
搞错了
所以每次都要试试几次才行
欢迎大家传授给我技巧
好
大家还有什么疑问吗
没得
这是中位数的定义
是吧
你说找三个数把357返回
我们看一下
这个问题我也不知道
看起来是不行的
说不定可以用percentile
我们来看一下
percentile只输出一个
刚才的问题是说
median中位数
我们只能取出来一个数
能不能多取几个
比如说中位数旁边的
左边一个右边一个
左边两个
右边两个
怎么取
看起来没有现成的工具
可能比较适合做一个作业
那么我现在想象的呢
比如说可以先把array进行排序
排序完之后
我们选一下
到底是从百分之多少
到百分之多少把它取下来
就是我设想
说不定有更快的方法
说不定有更快的方法
大家还有什么别的问题吗
让我来做个练习
做一些矩阵运算
比如说我们
想用一用三个世界上
最有名的三个矩阵
Pauli矩阵
我们怎么做Pauli矩阵
我们先取一个空的列表
然后我们加上第一个pauli阵
比如说array
第一个pauli是
第一行是[0, 1], [1, 0]
我这个矩阵我能写出来
就是带虚数的矩阵
可以
马上就到虚数了
我们问题总是很超前
我们看这有一个pauli的第一个
矩阵
我们看第二个矩阵
第二矩阵是
哪个在上面
哪个在下面
-i在上面
这里面我们顺便介绍一下
python里面的虚数，是用j来表示的
比如说1J 我们平时说的i
1j进行平方
我们看到这就是-1
我们把第二个pauli阵加进去
第二个pauli是
[0, -1j] 和 [1j, 0]
刚才的问题
刚才同学问题是说j是
numpy定义
还是就是python定义
跟numpy没关系
好
我们来验证一下
对
跟numpy没关系
好
现在有两个pauli阵了
看起来有点别扭
好
这是第二个pauli阵
第三个pauli阵
我们把它加进去
我打错了
第三个pauli阵是
[1, 0], [0, -1]
好
pauli矩阵最
最重要的
性质是什么
有同学说平方
我们来看一下平方
这里边的平方
就不是每个元素的平方
而是矩阵乘法是吧
矩阵乘法
我们来看矩阵乘法
它是点乘
它其实是用的是点乘
我看pauli阵的自相乘
这里用dot
看一下dot
Dot product of two arrays
它其实就是矩阵乘法的意思
我们看到第一个
不是第2个pauli矩阵
乘起来也是单位阵
虽然它是有负数的
表示
但是它的虚部
都是0
那么第一个pauli矩阵
我们把它两矩阵相乘
是吧
那么刚才我还听到同学说
最重要的性质是它的对易关系
咱们就定义一个函数
这个函数就是在
在这里
我们看我们定一个对应关系
这个函数的名叫commute 这个函数的
函数的文档是说commutation operator
ab-ba 那么我们如果要
定义
它
就是a和b矩阵相乘
减去b和a矩阵相乘
commute(a, b) 这个文档我就不打了
先a乘b 减去 b乘a
这函数我就定义出来
然后我们看commute
pauli
和第1个阵
来进行对易
看这是一个
2i
这是一个 -2i
我看第三个pauli阵
第三个pauli阵是1和-1
所以说我们看到对易关系
2i
乘以
pauli阵
第二个
我们看都是对的
每每一个
每一个元素都是一样的
所以说它们都是一样的
这里边我们可以说
它们所有都相等
我要非常随意的
又引入了一个新的命令
希望大家能够适应
因为numpy里边命令实在是太多了
如果大家忘了
如果大家不知道
这个all是啥意思
我们来看一下
所有的数组元素
都是True
我们看后边还是有参数的
可以接某一个维度
也可以接一些其他的参数
有兴趣
你也可以仔细看一下
如果心里边有数的话
遇到相应的时候
我们就可以一下子
就找到需要的工具
可以瞬间地把问题解决掉
好
我们刚才看到的是哪来着
好
这里
对吧
我们看了他的对易关系
那么对易关系
如果我交换这两个对易子
我们就看到它变成了负的
是吧
交换两个对易子
第二个pauli矩阵
跟第一个pauli矩阵对易的话
那么所有的pauli矩阵之间
都可以进行对易运算
1和2
下标
太混乱了
第二个和第三个进行对易的话
那么就会得到第0个乘以2j
好
希望同学们
能够通过pauli矩阵的练习
能够熟练numpy的
一些基本的运算
和比较一些操作
还有函数
那么有了这些操作之后
大家就可以比较得心应手地用
用一些很简单的
很精炼的程序写法
做一些复杂的矩阵运算
我们来总结一下
做作业之前
我们总结一下
numpy的数组功能是
非常的丰富
大家可以参考一下讲义的这个
地方
那么做更多的练习
这个讲义是参考资料二
它是由numpy的
作者写的书
这个讲义是非常的友好
也非常的权威
那么课上
我是碰到了什么函数
就给大家介绍了
如果忘了就打一下help
对于同学们也是一样的
大家可以猜一下
哪个函数可以完成一个矩阵
矩阵运算
或者是
向量运算的一些功能
那么当大家想找的时候
就可以试一下
打一下help就可以
知道这个函数怎么用了
就工具怎么用啊
所以说
今天讲的numpy
虽然讲了精华部分
但是今后还有很多的功能
我们会在实际的使用中
会遇到了就跟大家介绍一下
那么这也是我们一般来说
学习一门计算机语言
或者是接受一个新的工具的
一般的思路
我们先理解它的思想
numpy的思想是什么
numpy的思想就是
把一串内存空间
把它重新编号
编完号编成什么
它就是一个什么样的
线性代数的一个对象
那么在这个基础上
我们理解它的基本的思想之后
其实我们可以在用的时候
现学现卖
这都没有问题
在用的时候随时查阅帮助
随时地参考一些资料
其实就可以把程序写出来
那么这样我们是带着问题
来实现程序
那么实际上我们学到的东西
都会马上地用上
这样你用的越多
那么对它的印象就越深
而且留下印象的都是有用的
不会学到没用的东西
因为这个工具实在是太多了
这个永远有无穷无尽的工具
比如说在python的仓库里
仓库里边
至少有10万种工具
没有办法
所有东西
都了解到
在各取所需的过程中
我们学会看文档
学会能够找到工具
这是我希望同学们
学习到的核心的技能
好
大家还有什么疑问吗
没有什么疑问
我突然想起来
刚才忘说了一件事
就是pauli矩阵的特征值
我们举这个例子
还是不要跳过
然后pauli矩阵
特征值是这样一个 linalg
这是 linear algebra 的缩写
在讲义里面我写了
我是在这里写的
 eigvals 
第一个pauli矩阵的eigvals
这个就是算它的eigvals
我们看
eigvals就是0和-1
这就是pauli矩阵的特征
这也是0和-1
特别的巧
那么第三个pauli矩阵的
特征值也是0和-1
好
接下来咱们做一个作业
我看
上课之前
有很多同学已经开始做了
那么非常
同学们的热情
令我非常的振奋
依旧希望大家通过GitHub来完成
作业
那么没有网络食堂的同学
我把
我把贴到微信的群里
非常好
谢谢
这个作业是求
给定的一个N以内的素数
这个作业
看起来是比较简单的
但是它其实有时间限制
有时间限制
那也就是说
你的程序的效率是要有的
如果效率比较差的话
比如说我给你一个1亿
那么你可能这个程序就算不完了
如果默认的通过循环来做呢啊
也是可以的
比如说
我来做一个最弱的做法
其实可以用我们今天讲的numpy
它的某些很好的特性
可以找出某些数的倍数
然后另外还有一个工具叫做sympy
sympy
希望同学们能够举一反三
sympy它是一个符号计算的工具
可以把它理解成
python里边的mathematica
或者是
可能大家不知道
mathematica
那么刚才大家还记得怎么安装的numpy
对
在讲义的这一页
教大家如何安装numpy
那么其实你用同样的方法
安装sympy
然后sympy
因为它是一个
符号计算
也就是说它可以进行公式推导
那么它里边
说不定会有
求某一个数之内的
质数的函数
如果大家找到了
也可以使用
如果你找到了
numpy
和sympy之外的工具
可以一下子就找到素数
或者是
你需要找素数的时候
需要这些工具
你可以跟教学团队提一下
因为我们的测试环境
可能会没有
这些工具
你只要提一下
那么numpy的使用方法
上课的时候会讲
sympy不同的要求
同学们可以自己探索一下
接下来我就
争取能快速的
和同学们一起做一下
也很简单
作业已经下来了
我们来做这个作业
先下课
我在课间把这个作业做一下
下节课我们会总结一下上周的
作业
我想出了一个可能的
正确的
但是效率最烂的方法
然后事实证明
这个应该是对的
但是它的效率很低
同学们可以想一下
怎么来提升它的效率
基本的思想就是说
所有小于
小于 N的数
那么我们对小于n的数
进行一次循环
先假设它是素数
然后把所有小于它的数
再进行一次循环
如果有能整除它的
它就不是素数
非常好
比如说这个地方
到i 这样就多测了很多
比如说这里可以到根号i那么就
可以少测不少
那么如果经过这一个大循环之后
没有任何比他小的数
可以整除它的时候
除了1之外
那么它就是prime 
那么我就可以把它输出了
逻辑很简单
那么
比如说我打1万
1万还是可以的
但是10万就有点爆炸
看我的 CPU
应该是在疯狂的运算
是的
只有一个单线程
在疯狂的运算
这说明我的程序写的效率特别低
大家一定不要学习
但是算法大概是这样
我们留三分钟时间
给同学思考一下这个作业
然后三分钟之后
我们请陈晟祺同学总结一下
上周周末留的作业
GPA作业
然后我就来讲课
第一周作业的情况
先回顾一下
大家应该都知道
作业是什么就是
然后我就简单讲一讲
按照
按照顺序来输出
然后有简单的文件读写
还有一个非常简单的命令行参数
这些上课也都讲过
最后保留两位小数输出
黑盒测试上
我给大家一个非常简单的样例
然后我这里自己有两个
corner case
大家应该都看到了
我的数据
一个
一个其实也不是
corner case
对里面有比较多的
没有学分的项目
没有
叫做不算GPA的学期
有几个不算GPA的学生学期
然后第二个case是
他连续的挂一门课
好几回那种
然后我随机地生成了
完全uniform生成了
8个数据规模
分别从10~1万
最后的测试上呢
然后每个点上
我是按行比较
先检查位数
然后再检查
允许最后差一个小数
每个点限时是两秒
然后白盒测试上
分三个部分
代码风格
git还有实验报告
我待会都会讲
这是我新鲜出炉的评分情况
昨天评了一晚上
今天又评了一早上
大家就这样
5个人没交
然后我暂时不接受
补交
就是补交了
我也不算你分
但是最好还是交一交
说不定在期末的时候有用
就一个人还挺欣慰的
还好是交上了
然后有15个人
100分这个大于100分
我不是投着吗
我从这边我看一下
好
 OK超过100分
是因为白盒这部分
可以超过原来预定的20分
只要你写的够对
我就会给你持续的加分
然后有30个20个人
在分数字面上及格了
平均的白盒分数20.13分
所以大家的白盒分
应该都不用
太担心了
然后黑盒分就
看起来不是一个太好看的分布
就是满分的人比较多
然后0分的人也比较多
中间零零散散的都有些分布
总分的话呃还可以
看起来还可以
不过大家不用担心
这个不是最终的作业
这个作业成绩
最终不会直接这样折算到
我怎么卡住了
OK然后说怎么写
我就不讲了
大家都写过了
几乎
就算你没有过全部的点的话
你应该大概也知道怎么写
也知道自己犯了什么错
所以我就不详细的讲
这个题目要怎么写
如果要有什么学习
更简洁或更快的写法的话
于是可以看我们三个助教的标程
当然标程也不是最快的
但是
往往比大家考虑的情况多一些
或者说更简洁一些
或者咨询一下小助教
因为可以看到小助教
有6个人
5个人都是满分
还有1个人出了一些锅
我看他写的代码还是挺好的
然后大家也可以互相学习
因为有些人还是用了
比较高级的语言用法
包括我们课上
没有讲到的内容
然后黑盒问题
有那么三四个人
把GPA的对应写错了
你可能是因为太着急了
也可能是因为
比如我的测试里面
没有挂的科
对吧
所以你在你写错了也不知道
所以这就凸显出了
你自己测试的重要性
然后我就没有办法了
还有一些人假设学习的格式
就假设学习都是
2018分量的格式
但是我明确的写的
不一定
对吧
所以我特意卡掉
到了你这样只能得20分
就是我
我那两个看起来是对的格式
还有复杂度较高
长度较大
就是怎么说呢
有些人的写法本身
这语义上是对的
但是做了非常多不必要的操作
导致他的复杂度到了
N方
就是说它会对学期条数
每次插入一条的时候
都要在前面再做一次遍历
然后到1万的时候
你肯定是过不了的
常数较大的话
就有些人的操作会比较迷
他会对着一个字符串
反复的做一些奇怪的操作
导致数目比较大的时候
你还是过不了这个的话
建议咨询一下旁边的同学
特别如果你只有两个点
不过的话
一定要问一下旁边的同学
大家有什么更好的写法
输出格式不对
我们要背锅
今天不是有人在群
也不是这回事
今天上午
杰哥突然对我说
有些人输出
虽然只有3.7这样子
但我一想这不对
我要说保留2位小数
对吧
然后我想我就改了
重新卡掉了4个人
有一位同学从100分被我卡
到了0分
但是我后来发现
因为我发下来的grade
我实际上没有检查这件事情
所以
所以的确是
我们有一部分责任在这里面
因为大家可能看不出来
因为运行了一遍就pass了
对吧
但实际上你们输出还是不对
对
但是鉴于我确实在实验报告里
用粗体写的至少两遍
这样的话就是保留两位小数
我认为你们还是有责任
要遵守这件事情
其实我的grade是不对的
所以我们还会再商量一下
这些事
这个事情首先分肯定会被扣掉
一些
但是你也不会得零分
然后等我们商量以后
这件事情再确定
然后这也告诉大家
一定要认真看文档
不要太相信所谓的
然后这代码风格
占5分
占白盒里面的5分
也就是整个作业的5分
一个是没有空行上附近
这个就是我打开看起来
我又不用干
我vscode显示在
一块色块在那
我肯定要
扣分了
完全没有注释
也是
下面变量命名
我当时说了很重要
对吧
有位同学用了abcde5个数组
我确实不知道是什么
但是确确实实是100分
对吧
当然我也不能扣你黑盒那我扣你白盒
还有用总来当变量里面不止1个人
我至少数到5个人
我知道我
我看了也挺想笑的
然后下面一个我也扣了一分
为什么
就是有些是Python的
比如内置的函数
或者内置的保留字
或者关键词
虽然它可以用来当变量名
但是你不要这样做
包括有很多人用了
类似给我扣了一分
确实你可以用
但是这样的话
那内置的list函数
接下来就再也没法被调用
所以大家要写的时候要谨慎
如果你用现在的IDE
或者vscode
它都会提醒你
这个东西是一个
你要注意解决这个问题
还有很普遍的情况是
中间有个split
split完之后会出来
一个数组对吧
大家就对着数组
就疯狂的开始
这个数组的123456
开始疯狂的操作
然后有人写了整整四五十行
然后里面全都是数组加下标
首先我怀疑你接下来才改的话
你还知道那是什么
你还得看你
然后我也看不懂
其实就是这个的话
可以建议大家
用split出来之后
你先把它附上
一个正确的名字
然后你自己也写的也方便一点
加分项的话
就是有些人做得比较好
比如做了一些错误处理
虽然我没有给错误的数据
然后还有一些人用的
Python3.7的一些
新的特性
像 fstring
或者我不太记得了
对吧
然后还有一些人用上了numpy
我觉得也挺好的
虽然它用numpy
还比大家慢了一些
还有两位同学
两位上海交通大学同学
用了pandas
显着的变慢
就是没有必要杀鸡用牛刀
因为pandas内部数据表示比较
复杂
不是用来
做这么简单的事情
其实
然后git
我上次也说了
一个肯定会被扣分
对吧
还有确实有人用了
upload
homework这样的
有可能是时间来不及
也可能是没有考虑那么多
但是肯定要扣分
数数的人还是有那么几个
当然这次数数比较高级一点
以前数数123453
first second third
那个会用序数词了
但是还是没有任何的信息量
所以还是要扣分
然后有一个我没有扣分的事
就是有人写了merge1
:
merge2:什么
就是这个也不用写
因为确实没有必要这样写
对吧
因为你也不是在发布什么
windows
没有必要这么正式
还有我上次提到的
顺便提一下
我上次提到的
一般是用在正式的软件开发流程
里面
然后如果只有你一个人在写呢
一般是不用加的
当然你加上我也不会说你错
对吧
但是就显得比较长一点
可以不用加这个
OK
然后加分的话
凡是格式比较统一的
这样我都有加一分
然后还有人用.gitignore
隐藏忽略掉了一些
不必要的文件
也有加分
值得一提的是
有同学把
文件交上来了
有同学把python的
上来了
有同学把python的 pycache是交上来
还有同学把自己
造了一个很大的数据交上来
而且这些都没有必要
就是交文件的时候
只需要交有用的就可以了
可以避免污染仓库
只有你自己用到的文件
或者临时的文件
都不需要交上来
OK
算法思路没什么好说的
就是说清楚
我简单的扫一眼
能明白你在干什么就好
然后几乎所有人都能满分
有些人是4分或者3分
4分就是写的比较短 3分的可能的确是
太短了
或者你根本就没有写完的
大家都是这样
正确性测试也是5分
然后这是最后一个必选部分
大家看见自己的分数
对吧
然后有一位同学是6分
其他人都小于5分
应该是没有5分的人
你提到我就给你一分
当然如果你下面隐含了这个信息
我也会给你这一分
但是下面两点是必须的
一个是你要覆盖这么多情况
比如我的
你没有F没有F 你自己得
造一个对吧
你再看一看
对不对
这样你就得覆盖掉
所有可能出现的情况
这是很重要的
接下来的话
有大概4位同学
就生成了随机的数据
我觉得这个非常好
因为我们的数据也是随机生成的
如果你能过你自己的随机数据
我们数据应该就是不重的了
对吧
但是有同学把样例复制了20万份
我觉得不太有用
因为你样例算多少份
还是那些样例
对吧
然后还有很多同学
就是详细地讲讲
遇到了什么bug
怎么痛苦的
Debug
调两天调了三天
我看到你们非常辛苦的份上
这个也是能给分的
对吧
OK
然后还有不得分的
其实同学也很多
是因为程序很简单
我的代码逻辑又很清晰
所以我写的一定是对的
但是你黑盒为什么只有10分呢
虽然很
但是自信不能给你带来分数
所以这个是不给分的
然后我写正确性测试
希望大家意识到
这样一件事情
重要性
你写的程序之后
虽然说我不要求大家写正规的
比如单元测试
或者做回归测试
这样严谨的软件功能测试
但对你写的这样一个程序
因为你要面临你未知的输入
所以你应该做
比你拿的能得到的
样例输入更多的测试
来保证你的正确性
比如凡是的生成的
随机测试的同学
肯定都是100分
然后测试的比较多的
比如
我想想比如有位同学
用认识的很多人的成绩单测了
一下
所以我不知道这是怎么样的
当然是
但是我觉得这个也很好
因为他也是满分
对吧
他是这样写的同学
一般分数就不是很高
所以这个也能看出一点关系
对吧
虽然没有因果关系
但是有些统计上的相关性
OK
复杂度分析是一个加分项
所以不要求大家都掌握
大家可以简单的听一听
首先需要定量
就是说你不能说
你不能说这个数据越多
我程序跑得越慢
这句话相当于是没说
然后很多同学
会用一些记号
打得也不错
但是需要注意
需要用标准的记号
你应该用O
或者Ω 我们应该这样记好
然后有很多同学用o
因为小o和大O的含义是不一样的
然后大家可以注意一下
接下来我们就说
比如有n条成绩 m个学期的话
时间复杂度
说为什么说
因为对于每一条成绩
我们都要做一些操作 字典的操作
每一条都是O(1)的
然后其他的操作也都是常数的
所以你就认为
他是一个O(n)的
复杂度的话
为什么
因为这个m是不一定
我生成的数据里面
虽然学期只有那么多个
但是我可以生成了有多个学期
对吧
然后如果你是
学习数量一定的话
算作O(n)的
肯定也没有什么问题
同学说了
为什么是O(n)的呢
我只有那么多
但你最早的时候
读文件的时候
如果你直接把它readline
你全部read进来的话
那显然它就数据有多大
你就用多大内存
所以有这么大的内存占用
如果你采用的方法是
for line in file
这样的读法的话
你就没有 n在哪里
你python是一行一行
主要不是一次全部读进来
所以这有一个简单的区别在这里
OK
然后还有同学实现不同
有些同学
所以他黑盒没过
但他白盒
指出了自己写的
这里我还可以给他加一分
因为他分析的很对
但是我还是希望
他能改的快一些
因为没有必要这样写
还有同学指出
空间复杂度是O(1)的
你只要能解释的通
比如你说我学期只有那么多个
对吧
说是O(1)也没有什么大问题
所以
所以也可以
OK
然后还有同学做了很多测试
然后画了图
或者列出了一张表
或者带上系数做常数分析
我觉得是非常好的一个做法
然后都有相应的加分
浮点误差
大家应该有交流
就都知道浮点误差
所以写了浮点误差的
我给了1分
或者有些人只写了误差
两个字
我肯定就没给分了
因为这道题明显是误差
反正是什么
然后有很多人提到整数
就说我一旦乘10用整数之后
就不存在精度问题
当然如果大家用python的话
整数是无限精度的
我认为这些计划没有问题
所以没有扣分
但是大家意识到整数
你如果整数来算
不一定是无限精度
因为其他语言的指数
或者说对于机器意义上的整数
总是有一个范围的
你一旦溢出的话
就没有什么精度可言
所以要可以说的明确一些
然后乘10之后
用整数算
不是减小误差
它是没有误差的
你整数来做累加
这一部分是没有误差的
有的同学说
能够减少一部分误差
那么剩下的一部分去哪里了呢
然后接下来是另外一个问题
就是就算你用整数
最后0.01还是要加的
就是说就算你用整数
我们最后还是得放宽了0.01
不然你们还是会错
这个其实是误差
不是来源于浮点运算过程中
大家如果了解一些浮点数的话
我不会具体讲
给大家简单听一听
就是还有那么几个来源
一个是你把整数
No
你把一个整数转换成浮点数的
时候
通常不会有误差
但是如果是特别的整数除外
但是如果你把一个小数
转换成浮点数的时候
一般就会产生舍入误差
有几位同学给我证明一条定理
说
舍入误差就是
一个小数能够被精确表示为
浮点数的必要条件
是
它最后一位是5
对吧
这件事情
这件事情是对的
但是其实就我们
不会用到这样结论
但是你只要能明白
就是说小数转化成浮点数
会有误差
误差称为规格化
误差
或者表示误差
然后在你过规格化之后
浮点数的加减乘除
都是有误差的
就是运算的误差
最后你要把浮点数打印出来
你一定会把它变成更短的
然后这里是存在一个
使用
或者截断的误差
如果你不使用整数
算
全程使用浮点数的话
上面三个误差你都会遇到
然后你如果只使用整数算的话
你就只会遇到两个误差
实际上运算误差
只剩一部分
就是除法的误差
但是在浮点数里面
前面两个误差是非常小的
它的相对误差
可以小到2的-5次方
所以说几乎可以忽略不计
其实我们这次的误差
更多的是一个舍入误差
就是说在python里面
也不是在python里面
在计算机浮点数系统里面
舍入这件事情的规则
一般是四舍五入 四舍六入五留双
就是我们所谓的
round to even
就是舍入到偶数
舍入到偶数位
其实是
所以
不同于我们
不同于我们四舍五入
所以这个是带来误差这一方面
还有如果你python用百分号
那样格式化的话
它做的是截断
而不是舍入
所以这里也会带来
一个差别
然后如果你想解决这个问题的话
一个是首先可以观察到
我们只要两位小数
实际上你把它乘1000
完全为整数
算做整数加减乘
做整除
你完全避免这个问题
这是用
这是最简单的一个方法
也是最快的一个方法
或者用python的decimal
我也提示到
有很多同学也写了decimal
但是有个同学写在外面
写错了
很可惜
decimal可以设置很高的精度
精度可以减少运算和表示的误差
然后接下来之后
你就
可以用一个正确的使用规则
你告诉他
我要四舍五入到两位
它就会真的给你四舍五入到两位
然后这样也没有四舍五入的误差
这样能得到一个正确的值
对
最后简单总结
可能确实有点难
有很多同学感想里面
都写到花了几天在写
然后或者说有同学一晚上没睡
我还是挺心疼的
当然
昨天一晚上没睡
看起来像是感觉到一样
OK
然后不用担心
这个分数太低
是因为分布
我们接下来还会有进一步的调整
但是得分较低的同学
千万要明白自己是怎么错的
一定要把自己的程序改到对为止
因为我们发了数据
你可以自己想把自己的程序
改到对为止
然后要明白为什么写错了
这个错应该怎么避免
然后也欢迎大家找我们
或者找小助教
小助教分数也很高
交流一下
问题
还有看了感想之后
很多人都是查文档
明白了一些东西的话
那么我完全没有说怎么用
我把东西看着弄明白
它怎么用
那我觉得好
还有人就是问同学
或者也有人问我们这个挺好的
细节
很重要
刚才我已经提到了
比如输出小数位数
你差了一位
那就是0分没有什么好说
虽然这次我们也有过
但是以后
只要我们的评测是没有问题的
就是说
哪怕你的值是对的
格式上有问题
肯定是会被判0分的
包括行末这样的细节
虽然我们在评测的时候
会去掉它
但是希望大家也要注意这个事情
OK
转换思维方式怎么说
因为有些人都提到了
我之前写C写得很痛苦
然后我python之后
对吧
我还在用C的思维来写
然后怎么写都感觉很难受
因为大家要明白
 Python这个语言
它本身的目的就在于大量程序
就是降低写程序的门槛
或者说更符合你直觉地写
所以不需要像写C那样
比较死板
有些时候更符合你直觉的写法
往往是更好的
最后一点
不要赶ddl
当然这次大家都做得很好
也希望大家大作业不要感觉到了
因为我们接下来
就不是大作业
大作业的时间会很长
有十几天
希望大家千万不要拖到最后几天做
否则你会后悔的
 OK
下个星期我们的作业
难度可能会有所增加
从包括今天的
虽然看起来比较简单
但是因为我们会有一些时间的
限制
所以难度上会有所增加
大家不用
不用特意追求满分
就是说如果你没有更好的办法
不要在那里吊死很久
OK
然后我现在大概就讲这么多
然后如果有任何黑盒的问题
请赶紧找助教
然后白盒的话对分数有疑问
白盒的把它打开网络学堂的话
我每个人都写了几句评语
可以看括号里面的有加扣分理由
或者详细的分数过程
都可以看
有问题也可以都可以
找我
接下来我不准备再加新的内容了
我们简单的回想一下
今天都学习了什么内容
其中一个主要的部分
是
我们介绍了Python的模块
模块就是
能够把各种各样的函数集合在
一起
有一定的特定功能的
这样的单元
然后我们把模块
用import的方式
把它载入进来
载入进来之后
我们就可以使用模块里边的功能
拿到一个陌生的模块
肯定会一下子出现很多函数
那么这些函数
我们要知道
这些函数是怎么用的
我们讲了
help这样一个非常有用的函数
这个help本身可以查看
这些模块里函数的
在线的帮助文档
那么
我们就可以在使用的过程中
边用边学这样的
效率是非常高的
希望同学们
有些同学
可能不太适应
这种学习方式
大家尝试一下
在学习工具的时候
特别是进行实践
实践性学习的时候
这种方式还是非常有效的
接下来我们给大家引入了numpy
我们整个的这门课
实验物理大数据方法的核心部分
它不仅这个定义了一般的
这种物理实验中数据的格式
也代表了这些数据
在程序中的
基本的表示形式
而numpy中最核心的部分
就是
对数组取索引
甚至这样的索引
可以把一维数组变成二维数组
变成了任意维的数组
它本质上在内存中并没有变
只是它访问的顺序变了
它就可以变成
各种各样数组的形式
然后我们跟大家介绍了
在这种形式下
特别是二维数组
也就是矩阵
在numpy中的一些运算
我们用pauli矩阵跟大家
大家所熟悉的物理中
非常著名的pauli矩阵
跟大家演示了一些
矩阵运算的方法
希望整个的思路
大家还都有印象
我还觉得比较清晰
那么从明天开始
我们将把我们学到的这些东西
开始真正的用上
用到这个实验物理上
然后肯定有很多
是没有学到的
那么我们就边用边学这个边学边用
在这个过程中
希望能够和同学们
一起前进
一起成长
那么今天我准备的上课的内容
就到这儿了
大家接下来可以下课
可以自由讨论
嗯谢谢

