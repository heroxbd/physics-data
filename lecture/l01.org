* 序论
这门课叫“实验物理的大数据方法”。因为一些灵活的考虑，所以这门课分成了两个部分，一部分是《实验物理的大数据方法（一）》，一部分是《实验物理的大数据方法（二）》。物理系的同学要同时选（一）和（二）。工物系的同学选（一），（二）任选。

课程是算GPA的。

课程的标题在选择的时候，也经过了一番波折，考虑了很久才定下来。课程也没有太多的参考。纵观全世界去年只有伯克利开过一个类似的课程。所以说，这个课程里边可以参考的现成的课程比较少。因此，我希望同学们都能参与到教学建设的环节中来。比如，你在上课的时候哪个地方感觉不懂，或者是感觉讲的太慢，或者是讲的太快，肯定不是你的问题而是我的问题。大家一定要踊跃地提出你的意见，因为上课是为同学们服务的。我的目标是让同学们在暑假小学期能够尽可能学到更多的知识，掌握一些新的技能。

** 教师
首先我来自我介绍，我是基科2005级，2009年从清华毕业。之后9年时间我都在日本的神冈地下实验室，主要从事粒子物理实验工作，包括中微子和暗物质相关的实验。2018年，我回到了母校，到了工程物理系近代物理研究所。现在，我的主要工作是在四川锦屏的地下实验室来筹划、设计和建造我们国家的中微子实验。我参与国际合作研究，之前在日本的合作也在继续进行，包括中微子和暗物质的实验，我们国家的下一代的江门中微子实验也在其中。如果同学们对粒子物理和中微子以及这个地下实验室感兴趣，课下也可以和我一起讨论。

我有个爱好，在本科的时候属于业余爱好，现在属于半专业的爱好。它包括大数据分析，高性能计算，还有服务器的运营、维护、开发。作为爱好，我的水平不高，是业余级别。在课程中我会尽量的把我目前为止的毕生所学表达出来。如果表达的不好，欢迎同学们提意见。

** 实验物理
这门课叫实验物理的大数据方法。要搞清楚课程的内容，需要明确什么是实验物理。实验物理数理大类的同学可能在大一一入学就都知道：理论物理学家一般提出模型，从他的数学或者哲学角度出发思考，提出对大自然的模型。这个模型或者理论出来之后，实验物理学家就会在自然界中寻找这些模型的线索，即预测的现象。其中最重要的是可证伪性：模型是否能够用实验数据证伪。实验物理去采集数据，验证这些物理规律。

有一个说法，实验物理学家是非常费电的。如果大家忘了实验物理学家到底是什么，就看他这个耗电量很大的人基本上都是实验物理学家。比如，欧洲核子中心一年的耗电量是太瓦时量级。作为对比，北京的二环以内包括崇文宣武，人口200多万，大概只是他的10倍。一个实验室人口是千人量级，它的耗电量相当于200万人在一个城市里面的耗电量。实验物理本身要观察物理现象。对控制变量来改变物理现象发生的环境，一般我们把它叫做狭义的实验，比如我们平时说的实验室。对不能控制条件的实验，我们把它叫做观测，比如天文观测中造望远镜。严格上来讲，高能宇宙线的实验或者射电的实验都属于观测。实验物理要从取得的数据出发来进行统计推断，用统计学的知识来证伪物理规律假说。这是整个物理学科发展的规律。

** 大数据

“大”是相对的，所有你用一台计算机处理不完的数据，就叫做“大数据”。20年前的计算机处理不完的数据，现在或许可以处理了。可见“大数据”到底多“大”是“大”，一个相对的概念。在课程中，目前条件有限，给大家的数据不会大到一个一台电脑处理不完的程度。但是我们讲授的方法可以推广到非常大的计算规模。希望同学们在做练习和上课的时候能体会其中的方法。大数据作为流行语是一个商业的概念，目前人人都在讲，但是未必人人都知道。

大数据与大型的物理实验联系紧密。天体物理、等离子体物理、粒子物理的大型实验都要求非常大的计算量。探索极端环境下物理系统的行为，是日常生活中不易探测到的。它有很多噪音，即使应用各种技术压低掉噪音，也还会有残留。只有采集很多数据进行分析，才能找出那亿万分之一的信号。大型的物理装置产生的数据都是海量的，我国的FAST天眼望远镜，每年要产生 $10^15$ 字节的数据。如何把这些数据转化成说脉冲星搜索结果这样的物理学结论，就需要应用大数据方法。

从历史角度，“大数据”还没有在商业流行起来之前，实验物理学就已经每时每刻地应对大数据的问题。CERN在90年代，给出了一份详细的报告，决策用大型机还是用民用级 Intel PC机来进行科学计算。这个报告经过长时间的论证和争论，最后CERN决定在 LHC (Large Hadron Collider 大型强子对撞机) 上用 Intel 的民用计算机组成集群，对 LHC 的数据进行计算。2012年Higgs粒子的发现也都是在民用级计算机集群上完成的。这是个人电脑及硬件集群成为科学计算主流的标志。当今，超级计算机国际排行榜上，大家都开始使用集群来达到世界顶级的计算能力。所以说，在大数据或者高性能计算发展的历程中，实验物理起到了非常核心的推动作用。

近年来，使用反了过来。“大数据”在工业界流行，大家把数据科学方法用在了各种领域，解决了各种问题n，获得了令人非常振奋的结果。它们又与理论计算机相结合，产生了许多新方法处理数据。比如，深度神经网络，商业概念叫“深度学习”，又反过来应用到实验物理，使我们对世界的认识又有了一个新的进步。

** 课程目标
本课程以实验物理为出发点，学习大数据方法的基础知识。这门课目标让同学们达成三点目标：

- 科学精神 :: 大家已经做过基础物理实验，也处理过实验数据，要理解数据处理中的科学精神。
- 自学能力 :: 从一开始养成良好的科研习惯，而且掌握典型的科学计算工具，并且能够通自学上手新工具。
- 使用工具 :: 工具有各自的适用范围，不同的工作场景适合使用不同的工具。针对问题和任务来选择合适的工具。

** 课程计划

- 第一周 :: 版本控制Git的入门，Python的入门；
- 第二周 :: Python 科学计算，可视化；
- 第三周 :: 命令行工具；
- 第四周 :: 高级工具。

** 数据分析指导原则

数据分析指导原则对实验物理乃至其他实证性科学研究适用。这几个原则会贯穿始终。

“复现”原则。无论做什么样的研究，科研成果一定要能够被同行重复出来。不能我在这里测量精细结构常数是1/137，误差很小，你在上海测得精细结构常数是1/141。不仅需要在实验条件下可以重复，而且需要实验结果以人类语言，比如论文、报告，还要以计算机语言表达，计算程序需要公开。这样他人才可以重复你的结果。这是科学研究的最基本的精神，它和可证伪性伴随。一个理论不能正着说和反着说都对，这就不具备可证伪性了。“复现”与“可证伪”是区分科学与伪科学的标志。今后大家如果在媒体上看到谁有了突破，你要先问两个问题：“他所验证的结论是可证伪的吗？他的结果可以被他人重复吗？”

“透明”原则。在处理数据时，往往需要经历多步，无法一蹴而就。数据分析的每一步中间结果都应由人类理解可以被直接阅读。否则如果我们不知道它是对是错，到最后一步才知道它错，就非常难以找到错误原因。

“一次”原则，或“一次且仅一次”原则。不论写文章，还是写程序，禁止进行复制粘贴操作。在需要对一段程序进行修改，完成另一个内容时，不要把大块的程序切下来。这样做叫“自我重复”，它的坏处在于当你发现这部分需要进行修改时，你已经复制到其他地方的程序不会跟着被自动修改。如果你忘记了已经复制了9处，却一共改了8处，那么当这个项目变得很大时，就非常难找到错误原因。一定是有意义的信息都只放在统一的地方。

“最佳工具”原则。尽量使用高级语言。如果使用一个工具很得心应手，并且它非常适合要做的事，就一定要使用它。即使这个工具和别人的不一样，我们要想办法把它和别人的联合起来。如果能做到这一点，我们就可以在面对任何任务时都挑选比较合适的工具。该用锤子的时候就用锤子，该用电锯的时候就用电锯。这样才能节省自己的时间，也能够最有效地实践上面的三个原则。

这门课会以 Python 为中心介绍数据处理。但是，Python 未必永远都是最好的工具。所以我们这门课
不叫 “Python 数据处理与科学计算”，虽然现在几乎如此。但是不保证今后还用 Python 进行教学。

** 课程评价

平时作业占70%，以 Github 形式组织。平时作业以程序自动测试，还有20%是“白盒”测试。助教与我会读作业程序，看 Git commit 是否符合规则，是否养成良好的习惯。

大作业占30%，取材于实验物理的不同场景，覆盖物理学的方方面面。大作业也可以由同学自行提出，非物理的学科中数据处理类的任务都可以做为大作业。大作业分两阶段，对应前两周和后两周。只选《实验物理的大数据方法（1）》两学分的同学，要完成前半部分。同时选了《实验物理的大数据方法（2）》总共4学分的同学，要完成所有的大作业。大作业有三个主题：

粒子物理实验，取材自 Ghost Hunter 中微子数据分析排位赛，竞赛结果可以课赛结合的形式作为大作业。也可以在竞赛的基础上继续提高。未参加过竞赛的同学，也可在网站上看到物理背景。

天体物理观测。

凝聚态物理实验测量。

大家的物理课的进度都差不多，但是编程基础差异较大。希望基础较好的同学多帮助周围的基础薄弱的同学。

如果你的精力太旺盛了，上课太简单了，可以尝试多做几个大作业。

自定义大作业的要点是：问题描述，学科背景，数据输入输出，评分标准。可以由同学自己提出。

** 参考资料
Think Python，Python 科学计算讲义，在命令行进行数据处理，大蓝书。

The art of Unix programming：自由软件界的教父级人物，以道家思想剖析了 Unix 类系统中程序设计的优美和永恒性。到底是什么样的，它里面给出了很多切实的建议。我们这门课的透明性原则就是从这本书来的。

Learn X in Y minutes，你可以看到很多例子，改写成自己的例子，很适合初学者。

** Python

课程围绕 Python 展开，但是又不是 Python 程序设计。课程带领大家循序渐进地做一些 Python 练习。Python 是一门解释型语言，相对于编译型语言（C/C++）更容易调试。非计算机专业的同学有这样一门语言比较容易，日常工作比较舒服。Python 语法简明，很多是英文单词，与伪代码神似，即使外行也比较容易读懂或猜到意思。因此 Python 的书写效率比较高，易于快速的写出不那么差的程序。如果你要进一步优化，可能要花很多时间。但是对于大部分的工作，即使是科学的硬核工作，写出一个差不多的程序就已经够用了。计算机性能的发展实在是太快了，是人类跟不上的。5年前还要进行不断优化，5年后
一个差不多的程序可能胜任。Python 正好适应这样的趋势。

Python 可以直接调用多语言库。在学习物理，特别是计算物理时，会碰到 Fortran 或 C 程序。如果做统计分析，可能会用到 R 程序。如果大家组成一个团队，有的同学喜欢这个语言，有的同学喜欢另一个语言。Pyhon 可以作为各语言之间传唤的媒介，或者叫“胶水语言”，即把各种程序粘合在一起。Python 可调用很多程序的库，即使这个库是其他程序写的，也可以用 Python 程序调用它的功能。这非常易于
和已经有的工具进行组合，而且可以有效地防止团队协作中的偏好冲突，还大大丰富了 Python 生态的功能。

一个 Python 程序，很可能不是最优的。在实际工作中，遇到了一个必须优化的地方，可能会达到 Python 效率的极限。此时可以把这个核心部分替换成 Fortran 或 C，就可以进一步优化程序的运行效率。故而有这样的策略：面对一个任务，先写正确的可以运行的程序，然后定位耗时最多的点，针对这里进行优化；如果优化到了极致还不够，则使用其他语言替代。这个策略适用于一切科学计算问题，可渐进地完善，而不是非黑即白的卡死状态。在团队协作中，很多时候这些细节就决定了成败，因此 Python 是团队协作的最佳工具。

此外，相对于 Matlab 等专门的科学计算语言，Python 是一个通用语言。它的功能不局限于科学计算
和研究，而且在生活中的方方面面都可以使用。它的软件库丰富，可以完成非常多其他的功能。正是由于这些优点，Python 近期在科学计算领域得到了广泛应用。

** POSIX
POSIX，Portable Operating System Interface，是关于计算机操作系统的国际标准。操作系统是在计算机上运行的基本系统，在硬件与人类之间建立桥梁。如果我们在 POSIX 国际标准的环境里写一个科学计算程序，依此得到了一个科学成果，那么全世界的其他人，不管用什么操作系统，只要满足 POSIX，就都可以复现出我们的结果。反过来，如果一个环境只能是在某一个编译器的某一个版本下才能得出正确结果，只要换一个地方换一台电脑结果就错了，这就不是好的科学研究。

在学习中，要尽量的使用国际通用的环境，学习其中好用的工具，建立一个工具箱。满足 POSIX 的操作系统有 GNU/Linux，macOS，或者其他的类 Unix 系统。Microsoft 的 Windows 不满足 POSIX 标准，但是可以使用 Windows Subsystem for Linux 扩展来在 Windows 上实现 POSIX 环境。

正在使用 GNU/Linux 系统的同学不必作任何准备，请帮助周围的同学设置环境。macOS 的用户可以阅读 FAQ。Windows 用户先尝试安装 WSL，把课程的程序环境建立起来。

非常高兴，大家都成功地装好了环境。这个过程比预想的时间要长，这也是常见的情况。思想是一种，然操作起来是另一种。计算机未必能够理解思想，传递信息时会有问题。幸运的是，大家可以上课坐在一起共同解决问题。否则很可能一个问题卡三四天。
** 版本控制
版本控制会贯穿本课程的各个细节，包括每个作业和大作业。

举个例子来说明版本控制。你和室友要写一个小论文，你对室友说“我写第一章你写第二章，我把今天的版本给你，你收到之后在我的基础上改。”但是室友忘了，在你昨天的版本上改了。于是出现了冲突，在昨天的基础上，你有一个改动，室友也有一个改动。此时需要手动融合，你看一下他都改了什么，再把它手动地放到你的版本里。这是非常痛苦的过程，而且容易出错，也是小组成员容易闹不愉快的原因。此时最佳工具是是“版本控制”，顾名思义即给事物赋予版本。如“第一版”，“第二版”，“1.5版”，“1.7版”。

版本控制它就是一个，能够让本来不带版本的文件或资料带有版本的方法。

*** 石器时代

在上古的石器时代，版本控制是这样的：我今天写了一个实验报告，起文件名叫 v1。晚上我改了一下，为了区分防止搞混，文件名叫v2。睡觉之前，又改了几个错别字，我觉得它还不是 v3，就把它叫做 v2.2。我把实验报告发给队友 xbd 了，他更新之后防止跟我的 v2.2 搞混了，就在给我的文件名上再加了一个日期，发回给我。

这是原始的自发的版本控制思想。

*** 青铜时代
在青铜时代，POSIX 环境里出现了两个非常重要的两个工具， =diff= 和 =patch= 。 =diff= 的作用是把今天的文件与昨天的文件做差，把差分结果保存下来。 =patch= 把差分结果应用到旧文件上。

这个两个工具彻底改变了版本控制。比如，有一个公共版本，队友修改了第一章，得到了“差分2”的版本，他手里面握着一个“差分2”。我是加了第二章，得到了“差分1”。把我改的第二章和队友改的第一章合并起来，是目标。 =patch= 最大的创新是把把“差分1”与“差分2”加起来，或者把 “差分2”应用到“差分1”之上。一个公共版本之上的两个差分，非常像矢量运算的平行四边形法则，“差分1”和“差分2”具有可交换性质。 =diff= 和 =patch= 自动化了这个过程，只要调用工具即可完成。

可以想象从一个公共版本出发，5个同学一起合作，他们分别写5个不同的功能。完成后把5个差分叠加起来，就合并成一个最终的版本。

*** 铁器时代

铁器时代出现了控制服务。有一个中心的服务器，每个人都跟服务器交换差分。比如，我做了一个更新，给服务器推送一个差分。我想要其他人的更新，就从服务器上接收一个差分，更新我本地的版本。

在铁器时代，全球范围内自发的大项目产生了。比如说 GNU 的自由软件运动，以及 Linux 的内核，它们都得益于这样全球协作系统，使得全世界的人都可以向服务器提交差分。服务器把所有人做的工作都统合起来。

*** 当代

当代的版本控制是分布式的，跟铁器时代的区别是它不需要中心服务器。即使没有服务器，即使我们两个都是普通用户，我们也可以直接交换差分，使用工具自动进行。我们将使用 Git，它是分布式的版本控制的优秀代表。

** Git
Git 非常重要。生活中的痛点，之前写的报告找不回来了，上周的程序被覆盖掉了。一个人经过认真的思考，发明了非常巧妙的解题方法，并写出程序，效果拔群非常厉害。他想再进一步，继续优化算法，修改和重构程序。但是经过两个星期，他发现优化得不太对，新程序反而没有两个星期之前的效果好。但是之前的程序没有保存，没有办法再回到两个星期之前的高度了。他特别的难受，“复现”原则被破坏了。比如我在两个月前解决了哥德巴赫猜想，但是我忘了，怎么办？现在你到底信不信呢，这是很深刻的学术道德问题。大家一定注意，不要出现这种情况。

怎么解决？如果用石器时代的方法，是把两周之前目录存到另一个地方，再开始改。但这就有了重复，把很多程序复制粘贴出很多份了。今后如果有一个改动，希望改所有的备份，就会出现不一致。导致我们迷迷糊糊的在找程序的时候，百思不得其解，“我明明改了，但是怎么没改”。现实生活中经常会出现这种情况——不要这样做，这违背了“一次”原则。

使用 Git，养成良好的习惯，能解决以上所有问题。Git 是由 Linux 的发明人 Linus Torvalds 发明的。目前它支撑了全世界5000人以上的松散社区，在开发 Linux 操作系统的内核。它是“最佳工具”，不仅给5000名以上的人用，一个人用也非常好。

 所以说这门课上
 把作业设置成这样
 也希望同学们能够体验
 能够体验优秀的工具
 那么 Git 讲一些基础的概念
 在我们做实际练习之前
 Git 是这样的
 它把每一个把这个时间轴
 其实它切成了几个存档点
 那么比如说12345个存档点
 在这些存档点中
 我们在这个例子中
 一共有三个文件
 这三个文件
 比如说
 在第一次
 我们改了
 文件A和文件C 然后存一次档
 这样就有了一个版本二
 那么在第三次
 我们再存一下
 又有了版本三
 到第四次
 我们只改了 A1 和 B
 这样就有了版本四和版本五
 以此类推
 相当于我们有了很多存档点
 但是在这个时间轴上
 同学们可能会有疑问
 岂不是我们就已经有了5个版本
 那岂不是就违反了
 一次性的原则
 但是可以想见
 因为刚才我们说过
 这里边有这种差分的算法
 差分实际上来讲
 在存储的时候
 它其实只存了
 1、2和2、3之间的差分
 所以说实际上它只保存了一份
 并且以最简洁的
 最节约的方式
 把整个历史处理下来
 好
 我们下课休息一会
 下节课我们继续讲版本控制
 所以说它虽然是5个版本
 只不过它只是把中间的改变的部分
 都存下来了
 然后第一版还在
 到时候
 我要看第5个版本
 是它自己给你贴上的
 对
 你就可以来合计
 一般是空加空加
 100个空置页数
 是吧
 空是啥
 没文件
 有个第0版是什么也没有
 原初状态
 然后加一个
 好
 接下来的 Git 操作部分
 有很多命令
 可能大家记起来
 不是一下子就能记住的
 我在
 然后网络学堂上
 上传了一个 Git 的 cheat sheet
 大家知道什么是 cheat sheet 吗
 对 考试的时候它小抄
 那就是我们可以假想
 假如说有个 Git 考试
 然后你可能要带一个这样的小抄
 才能把它这个记住
 那么我们就不需要考试了
 这样有一个 cheat sheet 
 它里边有 Git 的常用命令
 大家可以参考一下
 本来我还打了50份
 然后下次我会带来
 给大家发下去
 现在大家可以参考
 网络学堂的电子版
 我们刚才讲到了
 Git 的基本结构
 我们看到这里有5个版本
 然后它存储的时候
 其实是存储了
 这5个的4个的差分量
 和第一个版本
 那么比如说
 我们看一个实际的
 Git控制的版本的例子
 比如说我们现在的讲义
 就在我的电脑上
 它其实就有
 可以看出看不太清楚
 其实就有这样一个
 各种不同的版本
 我们可以给大家展示一下
 在这里
 我把我的调大一点
 当然了
 然后我们看
 这是我的
 改动的历史
 比如说
 昨天6号30号
 29号
 然后最早是从去年开始
 去年5月25号
 然后我们可以看到
 对于每个
 我们都可以看到差分量
 比如说差分量
 红色的看不太清
 红色的是
 删掉了以后
 绿色的是加了一部分
 在这些历史上
 都会看到这些差分量
 那么这就是加的部分
 这是一个实际的
 这是一个实际的例子
 那么 Git 一共有三种状态
 刚才我们所看到的状态是说
 已经提交的状态
 一共有5个版本
 那么实际上我们在
 如何造出来这种版本呢
 有整个的文件
 文件夹里面有三种状态
 第一种是已提交
 也就是说
 已经这个版本已经存好了
 第二种是已修改
 也就是说
 如果在提交之后
 我们再做了别的改动
 那么这种状态
 就是说前一个版本在这里存好了
 我们又改了新的改动
 这个状态是已修改的
 然后已暂存就是说我们修改了
 之后
 我们可能修改了5个文件
 但是我们一次提交想
 有两个文件是联系起来的
 我们可能先把其中两个文件标记
 作为提交
 剩下三个文件下一次提交
 那么我们就有一个中间的标记
 比如说暂存的量
 那么实际上这个逻辑关系是
 这样的
 最开始
 还有一个原初的状态
 也就是说这个文件还不存在的时候
 我们可能要先加这个文件
 加这个文件
 就相当于打一个标记
 下次提交
 然后对于已经修改的文件
 就可以把这个文件
 不是
 对于已经提交的文件
 我们可以进行修改
 这时候它变成已修改的状态
 已修改状态
 如果我们把它打个标记
 那么它就变成标记
 等待提交的状态
 如果提交了之后
 那么它就会变成未修改的状态
 也就是说
 我把修改提交了修改
 已经存到了
 存成了一个新的版本
 那么它就变成了一个
 未修改的状态
 那么如果未修改状态
 如果把这个文件删除了
 所以说整个的逻辑是这样的
 所以每次我们创造一个新的版本
 比如说
 在这里边
 一个新的版本
 都是经历了这样一个过程
 这样看起来
 这样看起来稍微有点复杂
 我们可以在使用中慢慢体会
 使用久了就会觉得还是很科学的
 设计
 那么仓库之间是怎么通信的
 一般来说
 通信是
 如果有刚才我们说了
 Git 它是分布式的通信
 如果有几台
 几台机器
 它们互相怎么传递
 差分的量呢
 我们会接下来
 将会使用 SSH 的协议
 来进行通信
 那么如果他通信成功的话
 那么在不管有多少台
 计算机
 或者是多少个
 这样的数据库这样的仓库
 它都可以互相传递这种差分量
 这样我们每个人在本地的劳动
 其实都可以比较系统性的
 跟其他人进行分享
 那么 Git 的基本命令
 很多我们在刚刚安装的环境里面
 一般是自带 Git
 其中有一个 diff 是查看改动
 那么对于这样的命令
 比如说我到了一个地方
 我把它再扩大一下
 然后我打这个 Git diff
 它会告诉我这不是一个
 这不是一个
 Git 仓库
 这没关系
 我们只看一下命令就行
 我们如果想知道命令的具体情况
 我们可以打这个 man git diff
 就可以看到在线的文档
 这个文档是
 就是说
 告诉你git diff的
 所有用法
 注意这个文档会是很长的
 这个文档会很长
 所以说
 大家读起来
 当做一个字典来查阅
 就行了
 如果从第一个字
 读到最后一个字
 还是时间会比较长
 虽然有些同学可能很喜欢
 把字典从第一个字
 读到最后一个字
 那么下一个是
 比如查看状态 status 
 我们看一下status 我先不看了
 不一一列举了
 就这样 git status
 就可以看到它的状态
 然后添加文件
 刚才说的
 可以把这个文件
 从外面添加进来
 或者是把这个文件
 从已修改状态
 变成一个打的标记的状态
 那么还有命令是提交
 比如说把它
 把已经打了标记的文件
 把它提交上去
 或者查看历史
 查看历史比较常用
 我们来看一下
 就是说在这个里面
 如果我们查看一下历史
 你就可以看到
 可以看到我的修改历史
 放到比如说大家看这里这个是
 上面的
 这个地方是我修改的
 你看这里是一个标记值
 为了防止我们数据库坏掉
 它有一个校验的码
 然后这里边有作者名和时间
 和改动的内容
 那么我们看到这个地方
 其实是陈嘉杰同学改的
 我们其实两个人已经在写作了
 他改了我的一个拼写的错误
 好
 我们看 pull 是说
 从远程把差分都接收过来
 而这个 push
 就是把你本地的修改
 比如说你的差分量
 推送到远程
 好
 接下来我会带着大家做一个练习
 这个练习也是我们这门课的
 第一次作业
 大家在那个环境里边
 刚才我们安装的时候
 只是照顾了 Windows 的同学
 用 Windows 的同学
 用 mac OS 的同学
 还有用 Linux 同学
 现在都有 git 命令了
 你进入到怎么看
 有没有 git 命令
 我们到命令行里
 我们打 git
 我们看
 如果我们打出
 我们如果没有命令
 它就会告诉我们 “command not found”
 是吧
 我们如果没有命令的话
 就会有这样的提示
 如果有这个命令
 那么它就会有一些别的提示
 它就会给我们一些 help 
 是吧
 大家是不是都有命令了
 都有了是吧
 有没有同学没有 git 命令
 对终端里面
 我们稍微等一下
 打开你的 WSL 终端
 同学们都有 git 命令了吗
 然后
 我们继续
 同学们可以点击这个链接
 我们来做一个作业
 我们可以看到
 这里有一个 GitHub Classroom
 是我们使用作业的平台
 那么接下来的
 Big Data in Experimental Physics
 是我们课程的名字
 下面
 我们可以看到说
 有一个“Self Introduction”的作业
 如果我们点击
 接受这个作业的话
 就可以
 同学们都看到
 网络学堂的第0个作业了吧
 就是让大家注册了GitHub
 有没有同学还没注册 GitHub
 还有7位同学没交作业
 今天晚上之前把作业交了
 目前有7位同学
 没交第0次作业
 然后你要把自己的
 GitHub的ID
 提交到网络学堂上来
 这样方便我们评分
 如果不提交的话
 我们接下来作业就没法评分
 如果不提交的话
 作业就比较难评分了
 大家都有GitHub的账户
 是吧
 然后在浏览器里面
 我们就接受了这个作业之后
 就可以看到
 那么我们看
 “You are ready to go”
 你可以加入
 你可以不加入这个
 没有关系
 那么最重要的是
 下面一行
 然后我们看到这是我们作业的
 Git仓库
 我们看这个仓库里面
 有三个文件
 一个是 README
 就是说说明文件
 第二个文件是 grade.py
 可以给我们评分的
 然后第三个是 introduction.txt
 这个 txt 是我们要改的文件
 我们看到这个里面有
 readme.md 文件
 它其实就是在底下可以显示出来
 在网页里面
 也就是说我们要填写
 introduction.txt
 就是这样一个作业
 非常简单的作业
 我们看 introduction.txt 都是什么
 一般我的姓名
 我的学号
 和我的python版本信息
 比如说我要告诉他
 写上python版本信息
 然后课程感言
 可以说课太简单了
 或者说太难了
 或者说是人好多
 然后在进行这些操作之前
 我们需要做一个
 也就是说在我们本地
 已经有一个POSIX的环境
 我们要把这个环境
 跟我们的GitHub账号关联起来
 那要怎么关联呢
 我们回到这个前面去
 点之后
 就可以创建我们的仓库
 进行创建了
 然后
 我们希望设置本地到GitHub的访问权限
 其中有一点要生产ssh的密钥的
 我们刚才提到
 我们把本地和远端通信的时候
 都是用ssh协议
 那么这个协议
 要使用这个协议
 要先认证这个协议
 要产生一个密钥的对
 这个对
 如果同学们
 学过密码学的话
 948 
 可能需要一个对分一个私有的
 一个公有的东西
 生成这个对之后呢
 我们自己留住私有的部分
 把公有的部分交给GitHub
 这样
 这样就相当于我们身上有个虎符
 然后GitHub问你的时候
 他会用公有的部分来找你
 然后你掏出一个私有的部分
 一对如果对上了
 那么你就可以
 改动GitHub里面相应的一个仓库
 我们看一下
 怎么生成ssh密钥对
 好吧
 回到我们环境里
 ssh-keygen
 它其实是 ssh key generator 
 就是说汉语拼音读“gen”是吧
 那么如果我们打了这个命令
 它就可以生成一个
 但是我已经有了
 我如果生成一遍
 会出现什么问题
 我先把我的内容备份一下
 如果我们这样做的话
 它会告诉我们
 即将生成这个
 公钥和私钥的对
 那么下面是让我们输入
 到底它在放在哪里
 这个默认就行
 已经有了
 大家如果第一次使用的话
 会有这个情况
 你就不应该跳过
 所以我们自己随便取一个
 他不用输
 然后这个Enter passphrase
 其实无所谓
 让你这个虎符另加一道保险的
 如果你在这地方
 输入的 passphrase 的一个密码的话
 今后你每次都得做
 然后如果你是第一次练习
 所以不让它特别注重安全
 然后它让你们再确认
 你就直接回车就行
 这时候我们看到
 目前所生成的密钥形式
 是叫做RSA2048
 这个不知道大家有没有印象
 1028 
 我就生成了两个新的文件
 在我的home目录下.ssh下面
 就有两个目录
 一个是 id_rsa
 我看我里面有
 你给我们打开的话
 这个我不应该给大家看
 因为
 私有的
 然后这是公有的
 我们把公有的拿下来
 WSL 能复制吗
 那是看你用的终端不一样
 一般来说
 你可以选中一段文字之后
 右击标题栏
 然后菜单里有一个编辑
 编辑
 里面有一个复制
 不好
 大家可能用的工具不一样
 我们想办法把这个字符串复制下来
 不要照着打
 就太长了
 想办法把它复制下来
 之后到这个GitHub里面
 没有什么意见
 到我们的profile里边
 也不可否认的话
 在这个Settings
 在下拉菜单的Settings
 好像我有点迷茫
 最右边要翻翻一下
 在你的头像里有一个 Settings
 SSH and GPG keys
 然后GPG是GNU Privacy Guard
 意思就是说
 我们可以用它来发送加密的
 电子邮件
 或者加密的文档
 这个是怎么做的
 我不知道
 这个事情我再做一遍
 那么当我们进入GitHub之后
 我看到这个右上角
 有一个我的图像
 这个图像有个下拉菜单
 向它下面有一个Settings
 然后点击Settings之后
 就到了一个Personal settings的页面
 然后Personal settings
 就有一个选项卡
 叫做“SSH and GPG keys”
 这里面就我的 keys
 大家看到
 我已经有4个key放在这里
 如果要加一个新的key
 我们 title
 比如说
 然后刚才key我们已经复制下来了
 是吧
 title 写什么都行
 只要我还记住它是什么意思
 密钥我再说一下在哪呢
 我们在自己的家目录下
 如果我们cd都到了家目录
 然后cd .ssh
 就到了ssh相关的目录里面
 然后在目录里面
 cat id_rsa.pub
 这就是我们的公钥
 这个是公共的密钥
 我把这个放在这里
 大家参考一下
 有问题可以提问
 就把它复制到这个里面
 有问题可以直接提问
 复制的时候
 是指复制那一大堆这一块
 都复制进去
 把这些都复制
 复制的时候
 把整个文件的内容都复制进去
 已经执行完这个命令的同学可以做一个验证
 1179 
 这个验证
 大家已经做完了刚才的配置
 我们可以在命令行下打
 ssh -T git@github.com
 打完之后
 如果得到了
 这样一行提示的话
 “You've successfully authenticated”
 “but GitHub does not provide shell access”
 就说明我们已经成功了
 这就说明GitHub已经跟我们这个
 密钥
 你的虎符已经对上了
 老师是不是说Ctrl-C 不行
 然后问你 Yes or No
 打 Yes
 还差了一点
 还差了一个 Yes
 就是我们在第一次打的时候
 这个逻辑是这样的
 我们把我们的虎符给了 GitHub
 然后GitHub要验证我们
 我到底是不是我
 这有一步是吧
 但是我们也要验证
 这个GitHub到底是不是GitHub
 OK
 那么它会给我们一个提示
 提示会是什么样的
 我给大家演示一下
 我会出现这样的一个提示
 它是说让我们确认
 我们所打的GitHub
 是不是这样的GitHub
 我们可以看到
 GitHub给了我们一个虎符
 是这样的
 但是我们验证不了
 因为我们第一次用它
 所以说我们就打“Yes”就接受了
 这样一个密码
 但接受了之后
 从现在起
 就保证了
 每次跟GitHub通信
 都必须得看到
 这个密钥
 才会给它通行
 比如说我们打“Yes”的话
 就接受了GitHub
 Ip标志符
 有这样的密钥的情况下
 就是GitHub真的
 而不是别人伪造的
 盗用我们GitHub的账号的
 这样假的服务器
 钓鱼的服务器
 所以说
 然后我刚才对比一下
 真的跟你这个一样的
 就说明它是真的GitHub了
 交给你们俩都不看
 或者我们俩都被骗了
 但是我之前已经验证过GitHub了
 我把它存起来了
 刚才我用的时候还没出问题
 因为我已经验证了
 它是真的
 这是我们的
 大家都成功了
 这个 ssh -T 验证了
 那么我们就从GitHub
 把我们的作业把它拿下来
 大家还能找到自己的作业吗
 找到了自己作业之后
 然后看这里面有一个
 绿色的clone
 然后 clone 这个 ssh
 在这里面看一下
 我是管理员层面
 所以我可以看到大家的作业
 大家看的应该不一样
 这是我的作业
 然后看到了我的作业之后
 我们在这里面
 这里面有 clone
 我看到这里面有一个 clone ssh
 我们把它复制下来
 我们打 git clone 
 然后刚才复制下来的部分
 其实我们看到
 命名方式是有规律的
 git clone
 然后 git@
 刚才验证的时候
 用过
 然后冒号
 就是我们课程的名字
 然后
 是我们作业的名字
 然后一个减号
 后面是我们GitHub的
 每个同学GitHub的ID
 然后有同学问说
 把本地放在哪
 本地放在哪
 都可以
 大家按自己的喜好
 比如说我可以说
 homeworks
 创建一个新的目录
 大家注意用这个ssh
 更加安全
 所以说我们在这个网址上
 点一下 “Use SSH”
 然后我们打出了命令之后
 要找一个合适的目录
 因为已经下课了
 我迅速把作业做了
 然后如果有信心把作业做成的同学可以下课了
 如果想继续做作业的同学可以留下来继续做
 我进入到目录里边
 然后在一个introduction里面
 刚才我打了clone之后
 就出现了一个新的文件夹
 然后到这个文件夹里面
 刚才我们在这儿也用到了
 然后看一下
 然后看一下我的python信息
 commit 下说 “完成作业”
 因为已经下课了
 所以理论上不想同学压垮
 所以如果同学已经看懂了
 直接就可以放学了
 然后如果没有看到同学
 我在慢动作再来一遍
 好吧
 我再慢慢过来一遍
 刚才我们打了个clone
 clone 之后
 出来一个新的文件夹
 然后我们再先进入这个
 大家看一下这个文件夹里头
 有什么文件
 你看到有这三个文件
 来对比一下我们作业的
 作业的页面
 这几个文件
 里面是完全一样的
 大家都进到自己的目录里了吗
 我们再回来一下
 这个clone都已经成功了是吧
 成功之后
 我们打一个 ls
 看一下当前下面都有什么样的
 目录
 比如说这里面有
 和我的GitHub的ID
 大家都看到目录了吗
 看到之后我们进入到这个目录里
 cd  
 这样就进到这个目录里了
 这几个命令
 大家都觉得比较奇怪
 ls 是 list structure 的意思
 我看同学们都已经进到了
 这个目录里面
 我们再打一下ls
 一共可以看到三个文件
 还有这三个文件是吧
 然后我们在网页上
 会看到
 有这样三个文件
 这三个文件和我们
 克隆下来
 的三个文件是一样的
 那么我们对文件中编辑
 introduction.txt
 这里面给大家介绍一下
 比如说
 这里 introduction 的文件名
 那么我们在这直接打一个 tab 键
 它就可以自动补全了
  看来大家遇到了很多困难
 咱们设一个时间的上限
 如果这个5:20
 我们就彻底下课
 刚才下课
 好像没有几个同学回去了
 太辛苦了
 大家已经上一下午
 我们5:20之后
 大家可以来office hour答疑
 因为我们之前没有想到
 这个部分这么复杂
 所以我会
 如果是助教同学
 和我会准备一个文档
 然后大家课下可以借助那个文档
 完成这个作业
 然后我们看一下作业完成情况
 如果到了明天
 大家还没有完成的话
 明天课上我们再继续带着大家
 这个作业
 每个同学都会帮助每个小朋友
 请大家不用太担心
 我再来演示一下
 刚才我们已经进到这个目录里边
 进行这些改动之后
 我们可以看 git status
 我们看到
 是被修改过的
 是吧
 这修改过了
 然后我们也可以看git diff
 有什么差异
 好的
 我看差异是
 这里会让我输入一个 commit 信息
 然后把它保存
 为什么要输入用户名和邮箱
 因为在这个地方
 因为有一个用户名
 有一个邮箱这样显示出
 如果我们把每一次场地的用户
 所以这个时候我们可以用
 这个user.name
 你这样设一下
 大家注意别忘了 push
