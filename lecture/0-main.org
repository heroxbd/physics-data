#+LaTeX_CLASS: ctexart

* 序论
这门课叫“实验物理的大数据方法”。因为一些灵活的考虑，所以这门课分成了两个部分，一部分是《实验物理的大数据方法（一）》，一部分是《实验物理的大数据方法（二）》。物理系的同学要同时选（一）和（二）。工物系的同学选（一），（二）任选。

课程是算GPA的。

课程的标题在选择的时候，也经过了一番波折，考虑了很久才定下来。课程也没有太多的参考。纵观全世界去年只有伯克利开过一个类似的课程。所以说，这个课程里边可以参考的现成的课程比较少。因此，我希望同学们都能参与到教学建设的环节中来。比如，你在上课的时候哪个地方感觉不懂，或者是感觉讲的太慢，或者是讲的太快，肯定不是你的问题而是我的问题。大家一定要踊跃地提出你的意见，因为上课是为同学们服务的。我的目标是让同学们在暑假小学期能够尽可能学到更多的知识，掌握一些新的技能。

** 教师
首先我来自我介绍，我是基科2005级，2009年从清华毕业。之后9年时间我都在日本的神冈地下实验室，主要从事粒子物理实验工作，包括中微子和暗物质相关的实验。2018年，我回到了母校，到了工程物理系近代物理研究所。现在，我的主要工作是在四川锦屏的地下实验室来筹划、设计和建造我们国家的中微子实验。我参与国际合作研究，之前在日本的合作也在继续进行，包括中微子和暗物质的实验，我们国家的下一代的江门中微子实验也在其中。如果同学们对粒子物理和中微子以及这个地下实验室感兴趣，课下也可以和我一起讨论。

我有个爱好，在本科的时候属于业余爱好，现在属于半专业的爱好。它包括大数据分析，高性能计算，还有服务器的运营、维护、开发。作为爱好，我的水平不高，是业余级别。在课程中我会尽量的把我目前为止的毕生所学表达出来。如果表达的不好，欢迎同学们提意见。

** 实验物理
这门课叫实验物理的大数据方法。要搞清楚课程的内容，需要明确什么是实验物理。实验物理数理大类的同学可能在大一一入学就都知道：理论物理学家一般提出模型，从他的数学或者哲学角度出发思考，提出对大自然的模型。这个模型或者理论出来之后，实验物理学家就会在自然界中寻找这些模型的线索，即预测的现象。其中最重要的是可证伪性：模型是否能够用实验数据证伪。实验物理去采集数据，验证这些物理规律。

有一个说法，实验物理学家是非常费电的。如果大家忘了实验物理学家到底是什么，就看他这个耗电量很大的人基本上都是实验物理学家。比如，欧洲核子中心一年的耗电量是太瓦时量级。作为对比，北京的二环以内包括崇文宣武，人口200多万，大概只是他的10倍。一个实验室人口是千人量级，它的耗电量相当于200万人在一个城市里面的耗电量。实验物理本身要观察物理现象。对控制变量来改变物理现象发生的环境，一般我们把它叫做狭义的实验，比如我们平时说的实验室。对不能控制条件的实验，我们把它叫做观测，比如天文观测中造望远镜。严格上来讲，高能宇宙线的实验或者射电的实验都属于观测。实验物理要从取得的数据出发来进行统计推断，用统计学的知识来证伪物理规律假说。这是整个物理学科发展的规律。

** 大数据

“大”是相对的，所有你用一台计算机处理不完的数据，就叫做“大数据”。20年前的计算机处理不完的数据，现在或许可以处理了。可见“大数据”到底多“大”是“大”，一个相对的概念。在课程中，目前条件有限，给大家的数据不会大到一个一台电脑处理不完的程度。但是我们讲授的方法可以推广到非常大的计算规模。希望同学们在做练习和上课的时候能体会其中的方法。大数据作为流行语是一个商业的概念，目前人人都在讲，但是未必人人都知道。

大数据与大型的物理实验联系紧密。天体物理、等离子体物理、粒子物理的大型实验都要求非常大的计算量。探索极端环境下物理系统的行为，是日常生活中不易探测到的。它有很多噪音，即使应用各种技术压低掉噪音，也还会有残留。只有采集很多数据进行分析，才能找出那亿万分之一的信号。大型的物理装置产生的数据都是海量的，我国的FAST天眼望远镜，每年要产生 $10^15$ 字节的数据。如何把这些数据转化成说脉冲星搜索结果这样的物理学结论，就需要应用大数据方法。

从历史角度，“大数据”还没有在商业流行起来之前，实验物理学就已经每时每刻地应对大数据的问题。CERN在90年代，给出了一份详细的报告，决策用大型机还是用民用级 Intel PC机来进行科学计算。这个报告经过长时间的论证和争论，最后CERN决定在 LHC (Large Hadron Collider 大型强子对撞机) 上用 Intel 的民用计算机组成集群，对 LHC 的数据进行计算。2012年Higgs粒子的发现也都是在民用级计算机集群上完成的。这是个人电脑及硬件集群成为科学计算主流的标志。当今，超级计算机国际排行榜上，大家都开始使用集群来达到世界顶级的计算能力。所以说，在大数据或者高性能计算发展的历程中，实验物理起到了非常核心的推动作用。

近年来，使用反了过来。“大数据”在工业界流行，大家把数据科学方法用在了各种领域，解决了各种问题n，获得了令人非常振奋的结果。它们又与理论计算机相结合，产生了许多新方法处理数据。比如，深度神经网络，商业概念叫“深度学习”，又反过来应用到实验物理，使我们对世界的认识又有了一个新的进步。

** 课程目标
本课程以实验物理为出发点，学习大数据方法的基础知识。这门课目标让同学们达成三点目标：

- 科学精神 :: 大家已经做过基础物理实验，也处理过实验数据，要理解数据处理中的科学精神。
- 自学能力 :: 从一开始养成良好的科研习惯，而且掌握典型的科学计算工具，并且能够通自学上手新工具。
- 使用工具 :: 工具有各自的适用范围，不同的工作场景适合使用不同的工具。针对问题和任务来选择合适的工具。

** 课程计划

- 第一周 :: 版本控制Git的入门，Python的入门；
- 第二周 :: Python 科学计算，可视化；
- 第三周 :: 命令行工具；
- 第四周 :: 高级工具。

** 数据分析指导原则

数据分析指导原则对实验物理乃至其他实证性科学研究适用。这几个原则会贯穿始终。

“复现”原则。无论做什么样的研究，科研成果一定要能够被同行重复出来。不能我在这里测量精细结构常数是1/137，误差很小，你在上海测得精细结构常数是1/141。不仅需要在实验条件下可以重复，而且需要实验结果以人类语言，比如论文、报告，还要以计算机语言表达，计算程序需要公开。这样他人才可以重复你的结果。这是科学研究的最基本的精神，它和可证伪性伴随。一个理论不能正着说和反着说都对，这就不具备可证伪性了。“复现”与“可证伪”是区分科学与伪科学的标志。今后大家如果在媒体上看到谁有了突破，你要先问两个问题：“他所验证的结论是可证伪的吗？他的结果可以被他人重复吗？”

“透明”原则。在处理数据时，往往需要经历多步，无法一蹴而就。数据分析的每一步中间结果都应由人类理解可以被直接阅读。否则如果我们不知道它是对是错，到最后一步才知道它错，就非常难以找到错误原因。

“一次”原则，或“一次且仅一次”原则。不论写文章，还是写程序，禁止进行复制粘贴操作。在需要对一段程序进行修改，完成另一个内容时，不要把大块的程序切下来。这样做叫“自我重复”，它的坏处在于当你发现这部分需要进行修改时，你已经复制到其他地方的程序不会跟着被自动修改。如果你忘记了已经复制了9处，却一共改了8处，那么当这个项目变得很大时，就非常难找到错误原因。一定是有意义的信息都只放在统一的地方。

“最佳工具”原则。尽量使用高级语言。如果使用一个工具很得心应手，并且它非常适合要做的事，就一定要使用它。即使这个工具和别人的不一样，我们要想办法把它和别人的联合起来。如果能做到这一点，我们就可以在面对任何任务时都挑选比较合适的工具。该用锤子的时候就用锤子，该用电锯的时候就用电锯。这样才能节省自己的时间，也能够最有效地实践上面的三个原则。

这门课会以 Python 为中心介绍数据处理。但是，Python 未必永远都是最好的工具。所以我们这门课
不叫 “Python 数据处理与科学计算”，虽然现在几乎如此。但是不保证今后还用 Python 进行教学。

** 课程评价

平时作业占70%，以 Github 形式组织。平时作业以程序自动测试，还有20%是“白盒”测试。助教与我会读作业程序，看 Git commit 是否符合规则，是否养成良好的习惯。

大作业占30%，取材于实验物理的不同场景，覆盖物理学的方方面面。大作业也可以由同学自行提出，非物理的学科中数据处理类的任务都可以做为大作业。大作业分两阶段，对应前两周和后两周。只选《实验物理的大数据方法（1）》两学分的同学，要完成前半部分。同时选了《实验物理的大数据方法（2）》总共4学分的同学，要完成所有的大作业。大作业有三个主题：

粒子物理实验，取材自 Ghost Hunter 中微子数据分析排位赛，竞赛结果可以课赛结合的形式作为大作业。也可以在竞赛的基础上继续提高。未参加过竞赛的同学，也可在网站上看到物理背景。

天体物理观测。

凝聚态物理实验测量。

大家的物理课的进度都差不多，但是编程基础差异较大。希望基础较好的同学多帮助周围的基础薄弱的同学。

如果你的精力太旺盛了，上课太简单了，可以尝试多做几个大作业。

自定义大作业的要点是：问题描述，学科背景，数据输入输出，评分标准。可以由同学自己提出。

** 参考资料
Think Python，Python 科学计算讲义，在命令行进行数据处理，大蓝书。

The art of Unix programming：自由软件界的教父级人物，以道家思想剖析了 Unix 类系统中程序设计的优美和永恒性。到底是什么样的，它里面给出了很多切实的建议。我们这门课的透明性原则就是从这本书来的。

Learn X in Y minutes，你可以看到很多例子，改写成自己的例子，很适合初学者。

** Python

课程围绕 Python 展开，但是又不是 Python 程序设计。课程带领大家循序渐进地做一些 Python 练习。Python 是一门解释型语言，相对于编译型语言（C/C++）更容易调试。非计算机专业的同学有这样一门语言比较容易，日常工作比较舒服。Python 语法简明，很多是英文单词，与伪代码神似，即使外行也比较容易读懂或猜到意思。因此 Python 的书写效率比较高，易于快速的写出不那么差的程序。如果你要进一步优化，可能要花很多时间。但是对于大部分的工作，即使是科学的硬核工作，写出一个差不多的程序就已经够用了。计算机性能的发展实在是太快了，是人类跟不上的。5年前还要进行不断优化，5年后
一个差不多的程序可能胜任。Python 正好适应这样的趋势。

Python 可以直接调用多语言库。在学习物理，特别是计算物理时，会碰到 Fortran 或 C 程序。如果做统计分析，可能会用到 R 程序。如果大家组成一个团队，有的同学喜欢这个语言，有的同学喜欢另一个语言。Pyhon 可以作为各语言之间传唤的媒介，或者叫“胶水语言”，即把各种程序粘合在一起。Python 可调用很多程序的库，即使这个库是其他程序写的，也可以用 Python 程序调用它的功能。这非常易于
和已经有的工具进行组合，而且可以有效地防止团队协作中的偏好冲突，还大大丰富了 Python 生态的功能。

一个 Python 程序，很可能不是最优的。在实际工作中，遇到了一个必须优化的地方，可能会达到 Python 效率的极限。此时可以把这个核心部分替换成 Fortran 或 C，就可以进一步优化程序的运行效率。故而有这样的策略：面对一个任务，先写正确的可以运行的程序，然后定位耗时最多的点，针对这里进行优化；如果优化到了极致还不够，则使用其他语言替代。这个策略适用于一切科学计算问题，可渐进地完善，而不是非黑即白的卡死状态。在团队协作中，很多时候这些细节就决定了成败，因此 Python 是团队协作的最佳工具。

此外，相对于 Matlab 等专门的科学计算语言，Python 是一个通用语言。它的功能不局限于科学计算
和研究，而且在生活中的方方面面都可以使用。它的软件库丰富，可以完成非常多其他的功能。正是由于这些优点，Python 近期在科学计算领域得到了广泛应用。

** POSIX
POSIX，Portable Operating System Interface，是关于计算机操作系统的国际标准。操作系统是在计算机上运行的基本系统，在硬件与人类之间建立桥梁。如果我们在 POSIX 国际标准的环境里写一个科学计算程序，依此得到了一个科学成果，那么全世界的其他人，不管用什么操作系统，只要满足 POSIX，就都可以复现出我们的结果。反过来，如果一个环境只能是在某一个编译器的某一个版本下才能得出正确结果，只要换一个地方换一台电脑结果就错了，这就不是好的科学研究。

在学习中，要尽量的使用国际通用的环境，学习其中好用的工具，建立一个工具箱。满足 POSIX 的操作系统有 GNU/Linux，macOS，或者其他的类 Unix 系统。Microsoft 的 Windows 不满足 POSIX 标准，但是可以使用 Windows Subsystem for Linux 扩展来在 Windows 上实现 POSIX 环境。

正在使用 GNU/Linux 系统的同学不必作任何准备，请帮助周围的同学设置环境。macOS 的用户可以阅读 FAQ。Windows 用户先尝试安装 WSL，把课程的程序环境建立起来。

非常高兴，大家都成功地装好了环境。这个过程比预想的时间要长，这也是常见的情况。思想是一种，然操作起来是另一种。计算机未必能够理解思想，传递信息时会有问题。幸运的是，大家可以上课坐在一起共同解决问题。否则很可能一个问题卡三四天。
** 版本控制
版本控制会贯穿本课程的各个细节，包括每个作业和大作业。

举个例子来说明版本控制。你和室友要写一个小论文，你对室友说“我写第一章你写第二章，我把今天的版本给你，你收到之后在我的基础上改。”但是室友忘了，在你昨天的版本上改了。于是出现了冲突，在昨天的基础上，你有一个改动，室友也有一个改动。此时需要手动融合，你看一下他都改了什么，再把它手动地放到你的版本里。这是非常痛苦的过程，而且容易出错，也是小组成员容易闹不愉快的原因。此时最佳工具是是“版本控制”，顾名思义即给事物赋予版本。如“第一版”，“第二版”，“1.5版”，“1.7版”。

版本控制它就是一个，能够让本来不带版本的文件或资料带有版本的方法。

*** 石器时代

在上古的石器时代，版本控制是这样的：我今天写了一个实验报告，起文件名叫 v1。晚上我改了一下，为了区分防止搞混，文件名叫v2。睡觉之前，又改了几个错别字，我觉得它还不是 v3，就把它叫做 v2.2。我把实验报告发给队友 xbd 了，他更新之后防止跟我的 v2.2 搞混了，就在给我的文件名上再加了一个日期，发回给我。

这是原始的自发的版本控制思想。

*** 青铜时代
在青铜时代，POSIX 环境里出现了两个非常重要的两个工具， =diff= 和 =patch= 。 =diff= 的作用是把今天的文件与昨天的文件做差，把差分结果保存下来。 =patch= 把差分结果应用到旧文件上。

这个两个工具彻底改变了版本控制。比如，有一个公共版本，队友修改了第一章，得到了“差分2”的版本，他手里面握着一个“差分2”。我是加了第二章，得到了“差分1”。把我改的第二章和队友改的第一章合并起来，是目标。 =patch= 最大的创新是把把“差分1”与“差分2”加起来，或者把 “差分2”应用到“差分1”之上。一个公共版本之上的两个差分，非常像矢量运算的平行四边形法则，“差分1”和“差分2”具有可交换性质。 =diff= 和 =patch= 自动化了这个过程，只要调用工具即可完成。

可以想象从一个公共版本出发，5个同学一起合作，他们分别写5个不同的功能。完成后把5个差分叠加起来，就合并成一个最终的版本。

*** 铁器时代

铁器时代出现了控制服务。有一个中心的服务器，每个人都跟服务器交换差分。比如，我做了一个更新，给服务器推送一个差分。我想要其他人的更新，就从服务器上接收一个差分，更新我本地的版本。

在铁器时代，全球范围内自发的大项目产生了。比如说 GNU 的自由软件运动，以及 Linux 的内核，它们都得益于这样全球协作系统，使得全世界的人都可以向服务器提交差分。服务器把所有人做的工作都统合起来。

*** 当代

当代的版本控制是分布式的，跟铁器时代的区别是它不需要中心服务器。即使没有服务器，即使我们两个都是普通用户，我们也可以直接交换差分，使用工具自动进行。我们将使用 Git，它是分布式的版本控制的优秀代表。

** Git
   
   
Git 非常重要。生活中的痛点，之前写的报告找不回来了，上周的程序被覆盖掉了。一个人经过认真的思考，发明了非常巧妙的解题方法，并写出程序，效果拔群非常厉害。他想再进一步，继续优化算法，修改和重构程序。但是经过两个星期，他发现优化得不太对，新程序反而没有两个星期之前的效果好。但是之前的程序没有保存，没有办法再回到两个星期之前的高度了。他特别的难受，“复现”原则被破坏了。比如我在两个月前解决了哥德巴赫猜想，但是我忘了，怎么办？现在你到底信不信呢，这是很深刻的学术道德问题。大家一定注意，不要出现这种情况。

怎么解决？如果用石器时代的方法，是把两周之前目录存到另一个地方，再开始改。但这就有了重复，把很多程序复制粘贴出很多份了。今后如果有一个改动，希望改所有的备份，就会出现不一致。导致我们迷迷糊糊的在找程序的时候，百思不得其解，“我明明改了，但是怎么没改”。现实生活中经常会出现这种情况——不要这样做，这违背了“一次”原则。

使用 Git，养成良好的习惯，能解决以上所有问题。Git 是由 Linux 的发明人 Linus Torvalds 发明的。目前它支撑了全世界5000人以上的松散社区，在开发 Linux 操作系统的内核。它是“最佳工具”，不仅给5000名以上的人用，一个人用也非常好。所以这门课上，作业都通过 Git 提交，希望同学们能够体验优秀的工具。

*** 基础概念
    Git 把时间轴切成了几个存档点，在12345个存档点中有三个文件。我们改了文件A和文件C，存档得到版本二。第四次，我们只改了 A1 和 B，得到版本四和版本五，以此类推。这五个存档点是否违背了“一次”原则呢？没有，Git 只存了 1、2 和 2、3之间的差分，实际上以最简洁的方式把整个历史保存下来了。

*** Git 的状态
Git 有很多命令，不是一下子就能记住的。使用时可以参考 Git cheatsheet。一个实际的 Git 控制的版本的例子是我们的讲义。它有不同的版本，可以用 =git log= 看到改动的历史。使用 =tig= 浏览，能看到每个差分，在图中红色的是删掉了的，绿色的是添加的。

Git 一共有三种状态，刚才看到的是“已提交”的状态，一共有5个版本。这些版本制作的过程，分三种状态。第一种是“已提交”，即这个版本已经存好了；第二种是“已修改”，即在前一个版本提交之后又做了别的改动。第三种“已暂存”，即我们修改了之后，使用 =git add= 把修改的一部分作为提交，标记成“已暂存”。使用 =git commit= 把“已暂存”的文件送到新的“已提交”状态上。

整个逻辑是：最开始 Git 仓库在原初状态，不存在文件。我们先加这个文件，打一个标记，放在“暂存”区域下次提交。我们可以修改“已提交”的文件，把它变成“已修改”的状态，如果给它标记成“已暂存”，就是等待提交的状态，提交之后就又变成“已提交”的状态。每次创造一个新的版本，都是经历了这样的过程。整个 Git 就是这样三个状态的这样循环，每次循环得到一个“已提交”的版本，成为下一步工作的基础。这给大家的一个项目推进的理念：步步为营，小步快跑，一点一滴地迭代。

*** Git 仓库的通信
    
Git 同步的时候，每个人有各自的计算机，需要进行分布式的通信，不管有多少个 Git 仓库，它都可以互相传递这种差分量。这样每个人在本地的劳动，都可以系统性地跟其他人分享。
如果有几台机器，它们之间可以使用 SSH 协议传递差分。

*** Git 的基本命令
**** diff 
     =git diff= 是查看改动。它的文档可以在 =man git diff= 查到，里面有 =git diff= 的用法。这些文档很长，是 Reference Manual，最适合用来当作字典查阅。
**** status
     =git status= 是查看状态，同样可以在 =man git status= 查到说明。 Git 仓库所处的“已提交”、“已修改”、“已暂存”都可以通过 =git status= 查看。
**** log
     =git log= 是查看历史，从这个命令可以看到修改的历史。为了防止数据坏掉，它有一个校验码，有作者、时间和改动的内容。
**** pull, push
     =git pull= 是从远程把差分都接收过来。=git push= 是把本地的差分推送到远程。

** 作业
   GitHub Classroom 是作业平台，看到“Self Introduction”的作业，点击接受。作业中有三个文件 =README= 说明文件， =grade.py= 评分程序， =introduction.txt= 是要改的文件。

*** SSH Key
    在进行这些操作之前，需要把本地的 POSIX 环境跟 GitHub 账号关联起来。使用 ssh 的密钥来对 ssh 通信协议进行鉴权认证。SSH 产生非对称密钥对，一个私有一个公有。之后，每人留私有部分，把公有的部分交给 GitHub 。这就相当于我们身上有个虎符，GitHub 用公有的部分来找你，你掏出一个私有的部分，如果对上了就可以改动 GitHub 里面相应的仓库。

    生成ssh密钥，需要使用 =ssh-keygen= ，义为"ssh key generator"。它会告诉我们即将生成公钥私钥对，下面输入放在哪里，默认即可。所生成的密钥形式，是RSA2048。两个新的文件在 HOME 目录下的 =.ssh= 下面，一个是 =id_rsa= ，这个不应该给大家看，因为是私有的。另一个是公有的，把公有的复制下来，加到 GitHub 里面，SSH and GPG keys。

    验证配置，打 =ssh -T git@github.com= ，如果得到了 =You've successfully authenticated but GitHub does not provide shell access= ，就说明已经成功了，GitHub 已经跟我们的密钥（虎符）对上了。在 =ssh -T git@github.com= 需要打一个 “Yes”，其逻辑是，我们把虎符给了 GitHub，GitHub要验证我们，我到底是不是我，但是我们也要验证这个 GitHub 到底是不是 GitHub。它会给我们一个提示，GitHub给了我们一个虎符但是我们验证不了，因为是第一次用它，打“Yes”就接受了这样一个密码。接受了之后，就保证了每次跟 GitHub 通信都必须得看到这个密钥才证明GitHub真的，才会给它通行。
    
    从 GitHub 把作业 =git clone= 下来。

*** 例子
    把已有的程序 clone 到本地

    #+begin_example
      $ git clone git@github.com:physics-data/aplusb-heroxbd.git
      Cloning into 'aplusb-heroxbd'...
      remote: Enumerating objects: 29, done.
      remote: Counting objects: 100% (29/29), done.
      remote: Compressing objects: 100% (19/19), done.
      remote: Total 29 (delta 4), reused 0 (delta 0), pack-reused 0
      Receiving objects: 100% (29/29), 4.45 KiB | 4.45 MiB/s, done.
      Resolving deltas: 100% (4/4), done.

      $ cd aplusb-heroxbd
    #+end_example

    我一个程序 =aplusb.py= ，这是一个极简的 Python 程序，随后我们学习它的语法和语义。我将第一个 input 赋予变量 =a= ， 第二个 input 赋予变量 =b= ，完成了对它的修改。

    此时 =git diff=  可以显示我们在上一个 commit 之上做了哪些改动。比如说这里原来是一个空文件，只有之前助教同学给的提示，在这里加了两个变量。

另外我们用 git status 可以看到这个被改了。在这种情况下，就可以把改动累加起来。我们再看一下 status，
我刚才add了之后
它知道
现在是modified
我add了之后 把文件做了一个标记
标记为
它将用于commit
所以我们看它其实是已经
慢一点
慢一点
又不知不觉的
做的比较快一点
我重新来一遍
这个git diff
首先我拿git diff看了一下
我做了一下对应的改动
那么最后我们打git diff的话
就可以看到
我对这个文件
进行了什么样的整改
我们看到
加了输入a然后输入b
然后和print
这个部分
这个更改恰好是我们做的
所以我觉得很满意
这更改完了
所以我决定把这个更改
commit上去
commit之前
我先要给它加一个标记
说我准备提交这个文件
那么我加了这个标记
就是add
我刚才改的
是这里
所以把
就是说
我 add 文件的意思是说
刚才我们讲到的 git 有三个阶段
刚才同学的问题
就是
说到底什么是做标记
我们再来回顾一下
因为这个工具
大家第一次使用
所以很多概念还不太清楚
所以一旦我操作的时候
大家也跟不上了
一定要提问
所以谢谢这位同学
刚才我可能讲的太快
那么一会儿上课回来
我给大家重新讲一下
这个 git 的 staged
好
我们先下课休息一会
好
我们进行上课了
咱们先讲一会
刚才有同学感觉
有点奇怪
我可能两个阶段
就能把这个问题搞定了
是吧
为什么要add
你比如说我现在
有了一个
提交之后
我做了一些修改
修改之后
我造一个新的提交就完事了
为什么还要add的一步做一个标记
然后再进行提交
我们先回顾一下
add是什么意思
我们先把这个项目
add的意思是
最开始它是一个提交的状态
然后我们进行了修改之后
变成了
已修改
已修改状态之后
有一个叫做staged
这个staged
中间态
没有一个统一的翻译
你就要打一个标签
就是说当我们把这个文件
打一个标签之后
那么staged的部分
在下一次肯定就会被交上
同学们不太理解说
为什么多出来的这样的一个staged
那么先打标签
然后再提交
我能不能直接提交
直接提交也是有一个方法的
比如说
我刚才如果不add的话
直接commit
那么这个时候会出现什么情况呢
那也就是说我
比如说我们仔细读一下
但是他重要的一部分就是说
no change added to commit
也就是说
我还没有add文件
它就把这个文件
放到即将commit 
这个队列里面
就是说我还没有给它打标签
让它commit
所以说它觉得没有东西
可以
这会出现这个情况
那么其实就是仁者见仁
智者见智
有些同学可能会喜欢
我就是忽略这个步骤
那么这个时候可以加一个参数
叫做-a
我们先看一下
这个-a是什么意思
昨天我们讲到
如果要看文件里边的
它的文档的话
可以用这个man
看它的文档
那么如果我们执行man git commit
我们看到这个屏幕
是什么意思
我们小抄里边不知道有没有
比如说应该是最全的
你看一下-a是什么意思
实际上来讲
如果我们忘了
commit都有什么参数
我们就可以通过这种方式来
我刚才在这儿
那么-a就是
也就是说
如果-a的话
可以跳过这个staged的过程
可以跳过打标签的过程
我们把所有的可以改动的文件
都提交成一个新的改动
它还提醒我们说
如果有新的文件
那么它不会被添加
那么刚才的这种情况
我们查了文档之后
我们知道 
我们可以看到
如果我们commit
好
可以了
就出来了一个编辑器
-m就是直接输入我们的
-m可以查一下
我们来查一下什么是 -m
-m在这
是吧
-m就是直接message
或者是 --message
也就是说之前我们在commit这个
时候
它会出一个窗口告诉我们，让我们备注 commit 所做的修改。但是如果我们想都在命令行里完成的话，我们就可以直接跟一个 -m。然后把要描述的话
我们看这样的话
当然不能这样说
这样说是要被扣分的
我先不这样输入
我们来展示一下-m是什么
刚才我没有输入
没有输入任何的注释
所以说它说因为我的
注释
是空的
所以它没有commit
所以我刚才的命令
我如果按一下上的话
就调出来上一个命令
刚才我直接-m的话
这个是
这里头我就用了引号
会更稳一些
这样就没有弹出来
在刚才的编辑器
直接以这个为提交的push给它
你们如果看
我们来看一下
整个我们改动的
这些差分的历史的话
就这一块
刚才我做的
这样就完成了之后
我们就可以把它push
 
我们有很多方法可以查看提交的注释。比如，查阅 git log，这里记录了改变的历史。在团队合作的时候，可以查询它的整个历史，并且对每一次修改都可以有非常明确的追溯
 
那么我们还有一个遗留的问题：为什么要三个阶段？而不是两个阶段就完事了。用 -a 的方法可以把三个阶段变成两个阶段。那么为什么要有三个阶段呢？比如说，我做一个改动：比如，这一行太长了，可读性比较差，我们想先把可以转化成多行。我们再看一下这个数据，又覆盖了原来的这个变量，那么，b 也覆盖原来的变量。这样一个过程，那么这个程序我改完了。看了一下，我比较满意。与此同时，这个时候我想看一下作业里边图形统计。这个时候我们 git status 的时候有两个文件被改。

这时候，助教过来了，发现我改的是一个违规的行为 git commit -a -m 。有的时候我可能改了之后，我只是探索一下评分。
所以说有的时候我改完就忘改回去了。
这时候我如果我没注意的话，我就直接 git commit -a，那么就把评估程序给改了。如果这样的话是要被扣分的。所以说这个时候怎么办，我想只把部分提交上去。这个时候三个阶段的作用就会显现出来。比如说，我只是想把它作为下一个提交，而另一部分不想作为下一个提交。如果我 git add 的话，我就只 add 这一个就行。我再看一下这个 status， 能够看到现在我们在 master 这个 branch 上。这一部分的改动，已经被加了标签，马上就要被提交了。但是下一部分就我没有 add 它，没有把它作为下一步要提交的备选。那么这部分它只是仍然是被修改的状态，它并不会被提交。那么我们来看一下，如果那个时候我们，不要再加 a ，commit 也追加 m。我们再看这个 log，
其实就是啊这样的一个log
对吧
有这样一个
加上这样一个提交
那么我看一下
提交有哪些改动呢
这个时候有另一个命令叫做 git show，它默认会把之前我们做的改动？？？。
看一下到底改了什么
我再慢慢的打一遍
git show
然后我们看一下这是什么
这是我刚才做的改动
然后我们把注释需要
我刚才对这个 grade 的改动
并没有放到差分
我们看一下
现在如果这个 git status
我发现
上一个文件已经进入了
那个文件已经进入了 unmodified 的状态，已经从打了标签的状态变成了 unmodified。
但是刚才改的grade的部分，还是可以的。
所以说在这种情况下，我们就可以无意中做了很多修改
之后我们再把这些修改分成各个部分做成逻辑上相对独立的
这样对我们自己未来经过了1年，5年，10年之后，回过头来再看，就会看到我们提交的历史，更加有逻辑性。
并且如果有队友的话，队友也比较容易理解到底做了什么样的工作。
还有grade 我们看一下git
我看一下 grade 我们到底对它做了什么样的
checkout 
checkout是什么意思
从我现在已经commit的一个改动里边，把最新的版本拿出来，覆盖我现在有一些。这是一个很危险的操作。
也就是说我之前没有提交的改动就都消失了。所以说执行这个命令的时候，一定要非常注意，这可能是你一下午或者是一天的心血。如果一下子 checkout 的话，可能就是被覆盖了。这件事情我是做过的，当时确实是痛不欲生。

覆盖之后，我们即使我把它已经 add 了
这个还可以覆盖吗
好问题
我也不知道
我们可以试一下
我们先覆盖一下
先给大家展示一下
覆盖然后git diff
然后就没了
我刚才修改就没了
那么我这次做一个更加
略微超额的操作
就是说
刚才同学的
提出了疑问
就是说如果我 add 之后
我这个checkout它
能不能
我们来试一下
它不会覆盖
我add之后 
我后悔了
怎么办呢
我看到我把它改成100分
我非常后悔
那么我就这样
又有一个新的命令
大家可以参考一下小抄
然后参考一下
网络学堂里面的
教程
这样reset之后
我们看到 
刚才是加了标签之后
它叫做staged
这个是unstaged
就是把这个stage取消了
这个时候
我们再看status
这个grade变成了modified
从staged的状态退出了
那么这个时候
我再checkout
它就成为了上一次
还没有公开
没有东西就是说我是我改了
然后没公开
还是说我改了也没啥
你改了也没啥
怎样才跟我
改了
它还会
这种操作应该也是存在
如果你发现了
请你告诉我
简单评分之前覆盖掉就好
太简单了
然后刚才我们看一下
你再看一下status
第二行
有一个不一样的地方
它说
这个意思是说
我们现在的本地，比远程领先的一个层面。因为刚才我如果看 git log 的话，我们刚才是把这部分 push 上，但是这个是我们刚才加的在这个状态下。我们可以看到，本地是多了一个 commit，还没有 push。就是说我们再处理一下，我们看 status，我们验证一下远端，看到了刚才的这个 commit，以及今天其他的讲的部分。


如果我已经commit了，但是我 commit 了之后我后悔了，不想把它处理了。这该怎么办？这个操作其实比较复杂。
比如我真的把这个程序给它改坏了，然后我 commit， commit 之后，我知道它坏了。这个时候我打 log 的时候，我看到一个怎么会有这个东西。然后我 git show 看一下它都是有什么样的 commit 的时候，发现这个地方好像打错了。
但是我现在想把它扔掉。这是我们需要一个新的命令，rebase。什么叫 rebase？之前我们在讲版本控制的时候，有一个叫做 base，即公共的版本，rebase 就是说现在这里有这样一个 commit，我想把我们可以理解为在它之上，还有一个未来的一个指针，那么我想把未来的指针，在它的公共版本向前移动一个位置，移动到这个地方。
这样的的操作就是 rebase。
我们看一下现在执行 rebase 是怎么样的，rebase 之后 -i，它的意思是交互式地进行。
那么head2
是说从未来的指针叫做 HEAD
这是刚才你们讨论的是吧
也就是说它之前的两个
把它提交之前的两个这样的commit
大家可能没有看到
这里有一个
我最后一个
比较靠谱的commit在这儿
是吧
我们可以再试一下
如果我不想HEAD~2 HEAD~5
我们看到最近5个的
然后这时候我想把它
我想把这个不靠谱的
1386 
肯定会把它删掉
删掉的时候
或者是把它
就是在我的 
在我的编辑器里面都可以
用
其他的都可以
就把它删掉就行了
它其实就是把它
前面打了一个注释
其实就是把
把这个东西删掉了
我们
我看一下是那个
那么看一下git log
刚才的那个被删掉了
这样一个过程
这过程稍微复杂一点
但是今后同学们
需要的时候再用
还是没问题

有些同学可能会继续往下问，如果 commit 之后已经 push 了，但是我才想起来我搞错了，该怎么办。再改过来再 push，比如说改过来可以用 git revert。比如说我们再做点坏事，你在这儿把它（？？）放进去，就这样的话，有一个不靠谱的 commit。然后再 push 上去了，这简直是我职业生涯的污点，我怎么做了一个这样的改动，回来赶紧把它我返回来怎么办 T_T 如果是最近的 commit，就可以直接 revert。但是我也可以这样，我不知道看一下 commit，我会复制下来就可以，复制的时候其实复制多少都行
只要保证第一个字母在，因为它是一个散列的的标识，我复制一半也可以。给我默认的 commit 消息就是说把它 revert。 把这个 revert 做完之后我会发现，把它撤销了你记录还是要留下？？？

我们可以比如说现在这样的话我这样 revert 过去了，就回去了，我想把我的污点彻底给它清掉。用 git rebase
我们把污点清掉，连同改正污点的行为也清掉。我们来 push 一下，可是这样 push 失败了。就这种情况下就是说不允许这样。
大家可以思考一下为什么不允许这样的操作。时间是有方向的，这个世界是有熵的。我们可以想象这样一个场景：我们有一个项目，两个队员，有这样一个 commit，还有这样一个 commit，还发现有一个奇怪的 commit，都已经push上去了。然后远程队友也已经 push过了。

比如说在远端的话队友就觉得会很奇怪，因为队友看到我又把它加了一个别的，加了一个这样。我知道这个差分是这样的，每个差分都是依赖于指向前一个的。那么我们队友看到了这个之后，他发现这个地方要写成这个样子非常地奇怪，非常的迷惑。如果我用 revert，其实我是给他加了一个奇怪的 commit，以及一个反的 commit，然后我又加了一个这个。这时候我的队友看到的是这种状态，那么我队友也可以 pull 过来一个
一个 commit。这样队友可以直接同步过来。


