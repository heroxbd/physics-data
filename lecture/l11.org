* 命令行
  我们已经接触了几个基本命令，
- ls :: 意为 “list structure”，列出当前文件夹下的所有文件。
- cd :: 意为 “change directory”，改变当前路径的位置，跳到另一个文件夹里。
- sudo :: 意为 “super user do”，用最高权限来执行指令。
- apt :: 缩写是“Advanced Package Tool”，是软件包管理器，有些默认的环境里面没有 python3，我们是通过它来安装上 python3。
- vi :: 是文本编辑器，这个编辑器不是当前流行的风格，但是非常强大，如果同学们有机会去深入学习这个编辑器，会发现它是完全是另外一个非常强大的世界。
- nano :: 也是文本编辑器，相比 vi 简单易上手。
- emacs :: 是我使用的文本编辑器，基于 Lisp 语言定制性极强。

  “现代”风格的文本编辑器至少有一个窗口，有菜单，有光标，但这是1990年代发展出来的。对 vi 和 nano 这样的风格，操作都通过 Ctrl-W，Ctrl-X 等快捷键完成，同学可能不太适应。nano 编辑器确实较简陋，只进行基本的操作，不是主力用编辑器。这些编辑器是应急使用，做一些快速简单的改动。每个人都会发展出自己的编辑器偏好，发展出自己最喜欢的工作方式，在学习的过程中要慢慢体会。vi 和 emacs 的学习曲线都比较陡峭。最开始的三天会感觉自己在和自己打架，但一个星期之后，就会发现与计算机的沟通有一个巨大的飞跃。


  POSIX 环境的设计理念是每一个命令都要完成且仅完成一件小事，这叫做“Do one thing, do it right”。这可以促进分工协作：用户可以把各类小巧的工具挑选出来，组合起来，应用各种各样的场景，有无限可能。连工具的设计者都没有办法预测出来用户究竟是怎么用他的命令的。

  无穷无尽的组合可能，会让大家在入门时迷茫。世界太大了，我们要挑选一条路会很难受，特别是选择较困患者。一旦能够入门，它将是威力巨大的一个技能。我们不要求每位同学都能够入门，大家掌握能够完成作业所需要的最小限度。感兴趣的同学可以选择一个命令环境的自学教程。注意国内教程和博客的水平水平参差不齐，经常在博客中会有很多错误的信息，大家在查资料时不要误入歧途。

  初学命令行时，会有非常多的不适应。为什么要学习 POSIX 这个“反直觉”的系统呢？在大规模数据处理和科学计算中，我们站在世界的前沿。并没有其他的开发者，给我们开发出现成的工具来完成科学任务。但是这个环境里面的很多小工具——连开发者也不知道能够被用在科学计算上——反而会更加有效地完成任务。如果一个学科发展出了成熟的工具，让我们可以点几下鼠标就可以制出一个完美的图，那么这个学科就已经发展成为工业级了。如果在实验室中有这样的程序，可能是学长给大家准备了这样的比较友好的界面，但是这些界面往往年久失修会有各种bug。掌握命令行的技能非常有用，它只是入门时有些痛苦，但适应之后，你会发现它成为思维的一部分。我非常希望能看到一部分同学能够理解这一点，今后掌握这些小工具创造出来前所未有的组合方式和操作方式。

  Git 给我们一个“时光机”，能够高效地记录自己过去的工作进展。同时在空间上，Git 辅助团队协作，可让大家互换差分，高效协同。这种合作模式促成和造就了全世界的大规模的项目的崛起。

** 图形界面
   Git的客户端中，也有许多图形界面的，但是都不大好用，常有玄学错误。而且很难修改和定制。目前命令行的Git是“最佳工具”。

** 加密
   很多同学是第一次手动操作加密通道，我们看到在网络空间人与人是如何互相验证和建立信任的。如果这些加密可信，我们就可以与队友和远程的服务器不断地交换差分。这部讲义就是这样协同创作的。

** 学习要领
   《实验物理的大数据方法》涉及的内容很杂，与物理学其它学科很不一样。碎片化的知识和技能不成体系，需要点滴的积累。可以用造房子来比喻，房子的最终成品有居住的功能，但是在准备材料时，要铁、砖、木头，这些东西之间好像没有什么联系。初学大数据方法时就大概处于这样一个阶段，头绪很多，但是所有材料都是马上都会用到的，并不是孤立的技能。
   
   当今特别强调可复现研究和开放科学，当发布一个论文时，数据和处理方法，图和表格的程序都应与论文一起发布在共享协作平台上，例如 GitHub。

* Python
  我们从 Python 程序的基本构建、变量和数据类型学起。Python 是一门解释型语言，相对于编译型语言如 C/C++ 它更容易调试。在解释型语言中，可以直接看变量结构是什么，而编译型的需要特别的调试器来进行。Python 的语法风格简单，没学过 Python 的人看了一遍 Python 程序，也能够大概地读懂。最近突然出现了这么多程序员，Python 的简单起了很大作用。Python 还可以直接调用很多其他的库。Fortran 是从 1960 年代开始的科学计算的基本语言。经过多年的积累，有大量优秀的一个科学数据处理、微分方程等工具库。Python，还可以调用从前的工具，大大地丰富了 Python 的科学计算能力。同时它也可以调用C/C++，R语言等。 Python 的特性不仅可以使它自己的功能增强，还可以使团队合作更加顺畅。

  Python 是一个通用的语言，不仅用于科学研究，在生活中使用得更多。Python 可用来生成和管理操作系统，如 Gentoo Portage 是我目前参与的项目。Python 还可以构建极简的网站服务器，如我们的大作业平台的评分系统由 Python 写成。Python 易于上手，易于开发，在实际中应用广泛。希望大家能够能够喜欢上python。

** 参考资料
   课上没有办法覆盖 Python 的方方面面，许多细节和新功能需要自学。Python 有很多学习资料，对自学非常友好。Python for Everybody 是一个简明通俗的入门教材，甚至适合没有高等教育基础的大众自学，书中非常友好地解释每一个程序元素背后的理念和目标。初学 Python 时，这本书读起来会很开心。编程基础比较强的同学，可以使用 https://learnxinyminutes.com/ 在一小时之内快速入门 Python。它把 Python 所有的例子都总结到了一个网页。同理，如果你在这门课上掌握了 Python，在研究中需要快速入门其它语言，也适合使用这个网站，通过例子把 Python 的技能迁移到其它语言。
   虽然教学的内容是借助 Python 跟大家表达的，在实际中不要把思想拘于 Python，世界很广阔。

** 运行环境
   注意 Python 存在两个版本主要版本，Python 2 和 Python 3。当 Python 发展到 Python 2时，已经是流行语言。开发者开始反思，总结了犯过的错误，希望在计划一个大版本进行改正。但这会导致现有的程序无法使用。怎么办呢？加了一个版本号，可执行程序的名字也不一样，叫 =python3= 。这样，新版程序用 =python3= 执行，旧版程序用 =python2= 执行。
   进入 Python 3 的环境，需要用 =python3= 命令。Python 有一个增强的互动环境，IPython。“I”的意思是 interactive。这个环境好在有智能补全，在交互性操作时比较友好。如果你的环境里没有 ipython3，可以使用 =apt install ipython3= 来安装。Python 的另一个运行方式是 Jupyter ，它由 IPython 发展而来，好处是可以在网页上来进行 Python 操作，交互性更强，可以规避掉命令行，适用于探索。坏处是网页操作没有优秀的编辑器可用，写大段程序不大顺手，并且网页环境的批量处理能力很弱。 
   Jupyter 使得 Python 的应用更广，有了更多的用户在网页上编程。这是个双刃剑，一方面基础很差的人，摸了几下 Jupyter 试了几种肤浅的操作，就以为自己学会了编程，到处招摇过市；另一方面，
一个工具，可以受到全社会的关注，是非常荣耀的事。我推荐大家了解 Jupyter，把它与命令行组合使用，发挥最大的威力。但是它不能替代命令行工具。

** 基本算术运算
   :LOGBOOK:
   CLOCK: [2021-08-10 Tue 20:48]--[2021-08-10 Tue 23:00] =>  2:12
   CLOCK: [2021-08-10 Tue 15:59]--[2021-08-10 Tue 16:18] =>  0:19
   :END:

   可以做基本运算，还有一些其他的运算比如乘法。2的7次方是这样写，两个乘号。
   #+begin_src python :session op :exports both
2**7
   #+end_src

   #+RESULTS:
   : 128
   3/2是是严格的除法，
   #+begin_src python :session op :exports both
     3/2
   #+end_src

   #+RESULTS:
   : 1.5
   如果要整除的话写 3//2。
   #+begin_src python :session op :exports both
     3//2
   #+end_src

   #+RESULTS:
   : 1
   3%2 是取它的余数。
   
   #+begin_src python :session op :exports both
     3%2
   #+end_src

   #+RESULTS:
   : 1
   也可以使用高级功能，比如阶乘，阶乘需要使用使用 math 的库，要 =import math= 。3的阶乘是6，66的阶乘多大？
   #+begin_src python :session op :exports both
     import math
     math.factorial(66)
   #+end_src

   #+RESULTS:
   : 544344939077443064003729240247842752644293064388798874532860126869671081148416000000000000000

   这是 Python 的重要特点，整数是高精度的。在计算机的硬件里，每个数都要内存空间存储，我们如果学习C语言，需要知道有些整数用16比特，有些占用32比特，有些占用8比特，有的占用64比特。整数的范围是因定的。Python 又进行了一层抽象，使用软件实现了高精度的整数，在计算机可承受的范围内无上界。试试2的10000次方，
   #+begin_src python :session op :exports both
2**10000
   #+end_src

   #+RESULTS:
   : 19950631168807583848837421626835850838234968318861924548520089498529438830221946631919961684036194597899331129423209124271556491349413781117593785932096323957855730046793794526765246551266059895520550086918193311542508608460618104685509074866089624888090489894838009253941633257850621568309473902556912388065225096643874441046759871626985453222868538161694315775629640762836880760732228535091641476183956381458969463899410840960536267821064621427333394036525565649530603142680234969400335934316651459297773279665775606172582031407994198179607378245683762280037302885487251900834464581454650557929601414833921615734588139257095379769119277800826957735674444123062018757836325502728323789270710373802866393031428133241401624195671690574061419654342324638801248856147305207431992259611796250130992860241708340807605932320161268492288496255841312844061536738951487114256315111089745514203313820202931640957596464756010405845841566072044962867016515061920631004186422275908670900574606417856951911456055068251250406007519842261898059237118054444788072906395242548339221982707404473162376760846613033778706039803413197133493654622700563169937455508241780972810983291314403571877524768509857276937926433221599399876886660808368837838027643282775172273657572744784112294389733810861607423253291974813120197604178281965697475898164531258434135959862784130128185406283476649088690521047580882615823961985770122407044330583075869039319604603404973156583208672105913300903752823415539745394397715257455290510212310947321610753474825740775273986348298498340756937955646638621874569499279016572103701364433135817214311791398222983845847334440270964182851005072927748364550578634501100852987812389473928699540834346158807043959118985815145779177143619698728131459483783202081474982171858011389071228250905826817436220577475921417653715687725614904582904992461028630081535583308130101987675856234343538955409175623400844887526162643568648833519463720377293240094456246923254350400678027273837755376406726898636241037491410966718557050759098100246789880178271925953381282421954028302759408448955014676668389697996886241636313376393903373455801407636741877711055384225739499110186468219696581651485130494222369947714763069155468217682876200362777257723781365331611196811280792669481887201298643660768551639860534602297871557517947385246369446923087894265948217008051120322365496288169035739121368338393591756418733850510970271613915439590991598154654417336311656936031122249937969999226781732358023111862644575299135758175008199839236284615249881088960232244362173771618086357015468484058622329792853875623486556440536962622018963571028812361567512543338303270029097668650568557157505516727518899194129711337690149916181315171544007728650573189557450920330185304847113818315407324053319038462084036421763703911550639789000742853672196280903477974533320468368795868580237952218629120080742819551317948157624448298518461509704888027274721574688131594750409732115080498190455803416826949787141316063210686391511681774304792596709376

   这是 Python 的一大特色，它样做需要经过许多诸如内存判断，用多少内存，数量还会变化，多重判断会降低效率。但是现在计算机硬件水平，用效率损失来换取方便的接口是值得的。这也是本课程的基本价值观：如果能够节省人类的时间，不惜浪费计算机的时间。这与计算机专业研究有区别：计算机研究的目标，是让它更快，算法更巧妙，效率更高。

   整除有一些基本的约定，看几个例子
   #+begin_src python :session ob :export both
     -5 // -3
   #+end_src

   #+RESULTS:
   : 1

   #+begin_src python :session ob :export both
     -5 // 3
   #+end_src

   #+RESULTS:
   : -2
   往下面降。要注意，有些语言不是这样的约定，而是按照绝对值最小的方向去去降，那么-5整除3会给出-1。
   #+begin_src python :session ob :export both
     (-5 // 3) * 3 + (-5 % 3) == -5
   #+end_src

   #+RESULTS:
   : True
   
   除号和取余号也可以用在浮点数上。

** 布尔运算
   :LOGBOOK:
   CLOCK: [2021-08-11 Wed 20:34]--[2021-08-11 Wed 21:28] =>  0:54
   :END:
   布尔运算得到“真”“True”或者“假”“False”，是数理逻辑的范畴。否命题
   
   #+begin_src python :session ob :export both
     not True
   #+end_src

   #+RESULTS:
   : False

   #+begin_src python :session ob :export both
     not False
   #+end_src

   #+RESULTS:
   : True
   
   =and= 和 =or= 和数理逻辑的“和”跟“或”的定义是一样的。它的内部表示和其他语言很类似， =True= 和 =False= 不是全新的数据类型，它内部以数字形式存储。
   #+begin_src python :session ob :export both
     True + True
   #+end_src

   #+RESULTS:
   : 2
   严格的数理逻辑中，只是01运算，组成的加法群中， =True + True= 应该还是 =True= 。但是Python 中结果变成了 2。

   #+begin_src python :session ob :export both
     2 and True
   #+end_src

   #+RESULTS:
   : True

   此时 2 与 1 一样，都被当作 =True= 处理，即非零整数被在逻辑运算中是一个等价类。
   
   Python 的设计符合直觉和数理逻辑的定义。如果在布尔运算中用乘法也是自恰的，因为 =True= 是非零， =False= 是 0。这可以帮助我们理解 =True= 和 =False= 的实现。

   实际应用中 =True= 和 =False= 源于条件判断，如等号。“=”已经被赋值占用了，条件判断用“==”
   #+begin_src python :session ob :export both
     1==1
   #+end_src

   #+RESULTS:
   : True
   #+begin_src python :session ob :export both
     1==2
   #+end_src

   #+RESULTS:
   : False
   
   “不等于”在python里边是“!=”。

** 数据类型
   Python 有三个基本数据类型：

   - 整型 :: 我们刚看到的精度无限的整数；
   - 浮点型 :: 精度是有限的，常见的是64位高精度；
   - 字符串 :: 单个字符也是字符串，这与 C 语言不同。字符串拥有无限长度，在软件上把它进行了便利的实现和抽象。

   #+begin_src python :session ob :export both
     type(1)
   #+end_src

   #+RESULTS:
   : <class 'int'>

   #+begin_src python :session ob :export both
     type(1.5)
   #+end_src

   #+RESULTS:
   : <class 'float'>

   #+begin_src python :session ob :export both
     "今天" + "下雨了"
   #+end_src

   #+RESULTS:
   : 今天下雨了

   字符串用单引号和双引号都可以，一个好处是字符串里要输入一个单引号，可用双引号来引用。
   #+begin_src python :session ob :export both
     "'"
   #+end_src

   #+RESULTS:
   : '
   #+begin_src python :session ob :export both
     '"'
   #+end_src   

   #+RESULTS:
   : "
   这是双引号。 Python 3 所有的国际语言的符号都可内嵌到语言里，字符串可以直接使用汉字。相对于更基础的语言如C/C++，可以给我们非常大的便利。大家已经约定良好的处理字符串的方法都已经被 Python 作为默认功能。要入门程序语言，我们要打印“Hello World！” 向前人致敬。
   #+begin_src python :session ob :results output :export both
     print("Hello, world!")
   #+end_src

   #+RESULTS:
   : Hello, world!
   Print 是 Python 的一个函数，里面可加一个字符串。

** 变量
   Python 的变量与数学的含义类似，用以指代一个任何对象，例如字符串，
   #+begin_src python :session ob :results output :export both
     message = "This is an new era. 新时代"
     print(message)
   #+end_src

   #+RESULTS:
   : This is an new era. 新时代

   那么随后就可以用变量代替字符串。Python 的一大的特点是变量没有类型。我们可以看到，

   #+begin_src python :session ob :results output :export both
     message = 3840752916
     print(message)
   #+end_src

   #+RESULTS:
   : 3840752916

   =message= 这个变量既可以是字符串，也可以是整数。 Python 是无类型语言，这是很强的假设。如果语言的变量没有类型，那么它在运行中每次调用 =message= 时，都要检查它到底是什么类型。可以想象这样做需要额外的步骤调取内部的函数和库，Python 损失了很多效率。但是，我们喜欢！因为人类的脑子里也不区分整型、浮点型和字符串。Python 用它上层的软件库，给人带来了很多的便利，符合直觉是 Python 语言的一大特点。在做科学计算时，这个问题没那么简单了。学习 Numpy 时我们将看到，无类型变量的效率太低，我们只能再放弃一点便利，为了性能规定变量类型。
   
   变量本身也可以赋值给另一个变量，
   #+begin_src python :session ob :results output :export both
     m = message
     print(m)
   #+end_src

   #+RESULTS:
   : 3840752916

   =input()= 与 =print()= 对应，可以用来输入变量。例如：
   #+begin_src python :session ob :export both
     # q = input("Enter anything: ") # 输入 47042
     q = "47042" # 结果
     type(q)
   #+end_src

   #+RESULTS:
   : <class 'str'>
   注意得到的变量类型是字符串，如果需要数字，需要转换成整型。

   #+begin_src python :session ob :export both
     type(int(q))
   #+end_src

   #+RESULTS:
   : <class 'int'>

** 标准输入
   =print= 可以把信息打到标准输出，也就是屏幕上。那么如何从外界输入给程序信息呢？
刚才我们说了一个
print 把变量
输出的
我们再加一个
可以把变量输入
我打错了
大家在打错的时候
会经常看到这样的
这样的出错信息
看到这样的信息的时候
千万不要慌
那么我们仔细看一下
Trackback
现在属于交互模式
这个第一行
name error
那么我仔细地阅读了
刚才0.5秒的时间内
发生了什么
我仔细地阅读了
我意识到原来这个打错了
应该打成input
所以说我觉得初学的同学
容易
容易陷入的一个陷阱
就是说大家看到了
很多的出错信息
然后就感觉
这玩意根本不好使
我赶紧换一个别的方法
然后可能别的方法
又出现了很多别的出错信息
然后这个时候
比如说你问同学的时候
说这个东西不好使
然后别的同学可能会问
到底有什么样的出错信息
然后
所以说
然后你可能会把它忘掉
那么另外一个
可能会很难受
他不知道具体发生了什么
所以说我们在实际的使用过程中
重视这些出错信息
它有的时候不是很好
理解
比如说它这里边有很多别的东西
但是我们看这里面有一个东西
比如说我刚才说的
但是我们看这里面有一个
有一个值得注意的地方
就是我刚才打了字
就是说它输入进来
就直接输入到了里面
如果在里面它就变成了一个
这样的字符串
我们注意到这是一个字符串
我本来是想输一个数字
但是却有个字符串
刚才我们看到数据类型的部分
第一个类型是
1.5的类型是float的
然后好多的类型的这一块
我们看一下z的类型是什么
可以看到
还是字符串
其实还没有讲
我们主要是以
那么我如果想要用这个变量
做一个数字的话
就把它转换成
在这里边
等号也是赋值的意思
就是说
把自己的
就赋给了他
还是它自己
这个变成一个数
对
类型
所以我们可以把它变成
陈嘉杰同学给出了答案
我应该没记错
好像是对的
那种的话
是不是中文
中文的
这个东西
原来中文和日文
应该是在同一个区域
不是utf8
这样的
刚才我们说的是这个意思
刚才说的
刚才提到了
ASCII
不是所有同学都知道
ASCII是8个字节的
8个比特
一个字节的
对于这个字符的表示
这是一个ASCII的表
其实有效的是7个字
另一个是当做一个奇偶校验
那么也有扩展和使用的8个字
刚才同学问的
比如说ASCII字符
那么所以对于
128以内的
我们刚才又输了中文的
它为什么出现了这种情况
中文的其他国家的语言
特别是中日韩文字
经过了一个比较大的扩展
拓展目前的国际标准
叫做Unicode
大家可以稍微记一下
这一部分是我没有想到的事情
然后在这个Unicode里面
有各国的语言文字
其实还有各种严格的制度
比如说表情包
反正各种表情的肯定是有的
可以很丰富地表达出来
我们其实有Unicode做的漫画
在网上是有很多的
各种颜文字
拼成一块画的这种情况
那么
其实这一点
也是python的一个功能
也是区别于其他语言的功能
也就是它内建了
非常完整的Unicode的支持
比如说刚才我打的中文
比如说刚才打了中文
它可以直接查询到Unicode
这一点其实是非常伟大的一个
发展
因为在我当时
最开始用这个系统的使用
Unicode还没有统一
所以说
有几个关键的里程碑
其中一个里程碑
就让你的计算机成功显示出中文
这是一个
非常伟大的事情
大家说
可以想象
比如说我们之前
国家科技进步奖
当中就
有过一个汉字打印的
有汉字的激光照片
那么你们想一下
那个时候所有的计算机识别
都是ASCII
然后有这样的一个Unicode
其实是一个非常伟大的进步
刚才这是一个小插曲
我们刚才用了z是吧
z得到了365
我不知不觉用了一些其他的命令
那么在这个里面
我们可以用Ctrl-R
来搜索我们之前输过的
输过的指令
比如说刚才我
刚才那个场景是说
我们玩了一会
Unicode
然后我刚才忘了
我输入的记忆是怎么得来的
那么我按Ctrl-R然后
这样
它告诉我
比如说向上搜索的时候
然后我知道
我们z是通过
通过转化成整型来得到的
如果再
再摁一下Ctrl-R
它其实
如果摁Ctrl-S就是向后搜索
Ctrl-I是向前搜索
所以说我们如果在
python的环境里
打了比较多的命令之后
我们想查询之前的命令
怎么样
就可以通过Ctrl-R和Ctrl-S 
那么同样的道理
这其实是
整个的
我们的环境的约定
在命令行里面
如果我们把这些
打这些指令之后
那么我们同样可以用
Ctrl-R
Ctrl-S来进行搜索
后来我一天到晚都在打 ls
如果是这样就可以找到自己的
进行这样的一个
那么最开始的z
是通过字符的
得来的
这样就可以
使得我们程序跟外界有一个交互
交互可以是人类这样
打一个字母这样的一个
这个信息就转到字母里边了
那么它也可以是计算机来处理
和其他程序的接口
那么如果是
其他程序的接口
很多程序前一个程序的输入
就可以
前一程序的输出
就是可能后一个程序的输入
这样就可以链接起来
那么接下来
我们就来学习
一些基本的知识
我们就来做一个小的作业
这个作业的名字叫做
这个比较抱歉
因为课前准备的时候
我忘了
把这个作业提前留下来
还耽误一点
大家的时间
大家可以使用
这个作业的链接
就把链接
再做一遍昨天的事情
我先把分辨率给调过来
如果点了链接的话
几个同学是没办法看网络学堂
校外的同学不太
可以用网络学堂的同学
可以从网络学堂开始尝试作业
然后其他没有网络学堂的同学
用一下这个地址
我把它写下来
地址写在黑板上
我也来做一下这个作业
有没有坑
或者你按Ctrl+D
跟上一次作业是一样的
大家还记不记得
我们再来一起做一下
就是说现在我们
首先点击这个链接的话
都可以进到作业的界面
然后它会告诉我们
已经
有了这样一个东西
那么我们在这里
这个作业
可能跟大家也复习一下
上一次的作业的步骤
我这个作业好像比较早
所以我和
大家一起做一下这个作业
因为我也不知道这个作业
目前我也不知道这个作业怎么做
因为这个作业
是某个同学出的
最后我和大家一起来做
我们在ls看一下
这里都有什么
我先看一下
我什么也不做
能得多少分
我来看一下
我们来看一下
应该是int
我现在写成了这样一个
这样一个程序
我现在用nano
首先我input, 让a进入到这个变量
然后input b
进入这个变量
然后注意它是int
如果我直接加上
会有什么后果
我们先试验一下
如果a是一个字符串的话
然后b也是一个字符串的话
那么a加b会给出
字符串形式的
所以说如果我们忘记
把它转成int的话
还不对
如果我们把它转化成整型的
它就是我们想要的
所以这样一个程序
应该可以得分
这样的话
然后我看到我得分已经是
100分之后
然后把它 add 进去
首先我看一下git diff
我看一下
我都做了哪些改动
比如说这里原来是一个空文件
之前助教同学给的
提示
那么我在这里加了两个
在下面也有一个提示
然后我在这里
加了一行
那么我对我这个比较满意
所以我一直add
我刚才讲一个文件是 
另外我们用 status 来看
刚才我打了一个 git status
可以看到这个被改了
那么在这种情况下
就可以把改动加起来
我们就
我们再看一下 status 
我刚才add了之后
它知道
现在是modified
我add了之后 把文件做了一个标记
标记为
它将用于commit
所以我们看它其实是已经
慢一点
慢一点
又不知不觉的
做的比较快一点
我重新来一遍
这个git diff
首先我拿git diff看了一下
我做了一下对应的改动
那么最后我们打git diff的话
就可以看到
我对这个文件
进行了什么样的整改
我们看到
加了输入a然后输入b
然后和print
这个部分
这个更改恰好是我们做的
所以我觉得很满意
这更改完了
所以我决定把这个更改
commit上去
commit之前
我先要给它加一个标记
说我准备提交这个文件
那么我加了这个标记
就是add
我刚才改的
是这里
所以把
就是说
我add文件的意思是说
刚才我们讲到的git有三个阶段
刚才同学的问题
就是
说到底什么是做标记
我们再来回顾一下
因为这个工具
大家第一次使用
所以很多概念还不太清楚
所以一旦我操作的时候
大家也跟不上了
一定要提问
所以谢谢这位同学
刚才我可能讲的太快
那么一会儿上课回来
我给大家重新讲一下
这个git的staged
好
我们先下课休息一会
好
我们进行上课了
咱们先讲一会
刚才有同学感觉
有点奇怪
我可能两个阶段
就能把这个问题搞定了
是吧
为什么要add
你比如说我现在
有了一个
提交之后
我做了一些修改
修改之后
我造一个新的提交就完事了
为什么还要add的一步做一个标记
然后再进行提交
我们先回顾一下
add是什么意思
我们先把这个项目
add的意思是
最开始它是一个提交的状态
然后我们进行了修改之后
变成了
已修改
已修改状态之后
有一个叫做staged
这个staged
中间态
没有一个统一的翻译
你就要打一个标签
就是说当我们把这个文件
打一个标签之后
那么staged的部分
在下一次肯定就会被交上
同学们不太理解说
为什么多出来的这样的一个staged
那么先打标签
然后再提交
我能不能直接提交
直接提交也是有一个方法的
比如说
我刚才如果不add的话
直接commit
那么这个时候会出现什么情况呢
那也就是说我
比如说我们仔细读一下
但是他重要的一部分就是说
no change added to commit
也就是说
我还没有add文件
它就把这个文件
放到即将commit 
这个队列里面
就是说我还没有给它打标签
让它commit
所以说它觉得没有东西
可以
这会出现这个情况
那么其实就是仁者见仁
智者见智
有些同学可能会喜欢
我就是忽略这个步骤
那么这个时候可以加一个参数
叫做-a
我们先看一下
这个-a是什么意思
昨天我们讲到
如果要看文件里边的
它的文档的话
可以用这个man
看它的文档
那么如果我们执行man git commit
我们看到这个屏幕
是什么意思
我们小抄里边不知道有没有
比如说应该是最全的
你看一下-a是什么意思
实际上来讲
如果我们忘了
commit都有什么参数
我们就可以通过这种方式来
我刚才在这儿
那么-a就是
也就是说
如果-a的话
可以跳过这个staged的过程
可以跳过打标签的过程
我们把所有的可以改动的文件
都提交成一个新的改动
它还提醒我们说
如果有新的文件
那么它不会被添加
那么刚才的这种情况
我们查了文档之后
我们知道 
我们可以看到
如果我们commit
好
可以了
就出来了一个编辑器
-m就是直接输入我们的
-m可以查一下
我们来查一下什么是 -m
-m在这
是吧
-m就是直接message
或者是 --message
也就是说之前我们在commit这个
时候
它会出一个窗口
告诉我们
让我们写个描述的话说
这个commit到底干了什么
但是如果我们想
都在命令行里完成的话
我们就可以直接跟一个 -m
然后把要描述的话
我们看这样的话
当然不能这样说
这样说是要被扣分的
我先不这样输入
我们来展示一下-m是什么
刚才我没有输入
没有输入任何的注释
所以说它说因为我的
注释
是空的
所以它没有commit
所以我刚才的命令
我如果按一下上的话
就调出来上一个命令
刚才我直接-m的话
这个是
这里头我就用了引号
会更稳一些
这样就没有弹出来
在刚才的编辑器
直接以这个为提交的push给它
你们如果看
我们来看一下
整个我们改动的
这些差分的历史的话
就这一块
刚才我做的
这样就完成了之后
我们就可以把它push
在这里的话
你的显示了吗
我看到了
好
谢谢同学的提问
刚才我走的这一遍
有没有太快了
有没有同学说没有跟上
大家都跟上了
在哪里看我提交的注释是吧
比如说我有非常多的方法
比如说我看git log
看改变的历史
我们在这个地方
就看到我做了改动
我当时对我改动做的描述
然后这是之前陈嘉杰同学做的
就看到这些什么
我们看到历史
陈嘉杰同志做了一个描述
他做了很多事情
非常辛苦
他可能把我之前的
除了作业都被删掉了
因为我刚才发现是期待
可能下面最开始会有我的一个
提交
所以说我们可以看到
当我们进入团队合作的时候
可以查询它的整个历史
包括比如说看陈嘉杰同学
到底有没有用
第三个作业
然后发现他并没有
可能会
这就可以非常明确的追溯
好
刚才给大家演示的是
commit -a 是吧
就是这种情况
那么我们还有一个遗留的问题
就是说
为什么要三个阶段
而不是两个阶段就完事了
我们说了用-a的方法
用-a的方法
可以把三个阶段变成两个阶段
那么为什么要有三个阶段呢
比如说
我给做了一个改动
我们看做了改动
我们来做个改动
比如说现在我觉得
这一行太长了
可读性比较差
我们想先把可以转化成
比如说我想多写几行
变成了这样
我们再看一下这个数据
又覆盖了原来的这个变量
那么 b也覆盖原来的变量
这样一个过程
那么这个程序我改完了
看了一下
我比较满意
那么如果这个时候我想看一下
作业里边图形统计是什么东西
我们来看一下
就是说可以
感觉还是很长的
比如说我们对它做一个改动
比如说我可能对
是这样一个改动
我说我不小心做了一个这样的
改动
然后这个时候我们发现
git status
我们发现两个文件被改
是吧
然后这时候
比如说助教过来了
发现我改的可以
这是一个
这是一个违规的行为
git commit -a -m 
有的时候我可能改了之后
我只是探索一下评分
其他的想法是吧
所以说有的时候我改完了
就忘改过去了
这时候我如果我没注意的话
我就直接git commit -a 
那么就把评估程序给改了
如果这样的话
是要被扣分的
所以说
这个时候我想怎么办
我想只把部分提交上去
然后这个部分改动
我不想
那么这个时候
刚才说的这三个阶段
就会有用
比如说
在这个时候
我只是想把它作为下一个提交
然后这个部分
我不想作为下一个提交
如果我git add的话
我就只add这一个
对
我就只add这一个就行
我再看一下这个status
能够看到
现在我们在master这个branch上
就是说
这一部分的改动
已经被加了标签
马上就要被提交了
那么我们看到这一部分是
这部分是马上会提交
但是下一部分就是说
也就是说这一部分是说
我没有add它
没有把它作为下一步要提交的备选
那么这部分它只是
仍然是被修改的状态
它并没有
并不会被提交
那么我们来看一下
如果那个时候我们 
不要再加a了
commit
然后我们也不写m了
我们来用一下
编辑器
比如说
注意刚才我用了我最喜欢的
然后这时候我们再看这个log
其实就是啊这样的一个log
对吧
有这样一个
加上这样一个提交
那么我看一下
提交有哪些改动呢
这个时候有另一个命令叫做git show
这是一个昨天我们接触到的命令
应该在小抄里面有
git show是什么意思呢
它默认会把之前我们做的改动
看一下到底改了什么
我再慢慢的打一遍
git show
然后我们看一下这是什么
这是我刚才做的改动
然后我们把注释需要
我刚才对这个grade的改动
并没有放到差分
我们看一下
现在如果这个git status
我发现
上一个文件已经进入了
那个文件
已经进入了unmodified的状态
已经从打了标签的状态
进入到了unmodified
但是刚才的grade部分
我改的grade的部分
还是可以的
所以说在这种情况下
我们就可以无意中做了很多修改
之后
我们再把这些修改
分成各个部分
我把它们分别
做成逻辑上
相对独立的
这样对我们自己未来经过了1年
5年
10年之后
回过头来再看
就会看到
我们提交的历史
更加有逻辑性
并且如果有队友的话
队友也比较容易理解
到底做了什么样的工作
那么
还有graade 我们看一下git
我看一下
grade 我们到底对它做了什么样的
改动
那么我现在觉得
这个改动好像没有什么用
我可以做一个操作 
这个操作
其实大家可以能够去
可以把它记住
小抄里面应该是有
那么我如果做一个这样的改动
checkout 
checkout是什么意思
从我现在已经
已经commit的一个改动里边
把最新的版本拿出来
覆盖我现在有一些
这是一个很危险的操作
是不是
也就是说我之前
没有提交的改动
就都消失了
所以说
执行这个命令的时候
一定要非常注意
你可能是
一下午或者是一天的心血
如果一下子checkout的话
可能就是被覆盖了
这件事情我是做过的
当时确实是痛不欲生
所以说
从覆盖之后
我们即使我把它已经add了
这个还可以覆盖吗
好问题
我也不知道
我们可以试一下
我们先覆盖一下
先给大家展示一下
覆盖然后git diff
然后就没了
我刚才修改就没了
那么我这次做一个更加
略微超额的操作
就是说
刚才同学的
提出了疑问
就是说如果我add之后
我这个checkout它
能不能
我们来试一下
它不会覆盖
我add之后 
我后悔了
怎么办呢
我看到我把它改成100分
我非常后悔
那么我就这样
又有一个新的命令
大家可以参考一下小抄
然后参考一下
网络学堂里面的
教程
这样reset之后
我们看到 
刚才是加了标签之后
它叫做staged
这个是unstaged
就是把这个stage取消了
这个时候
我们再看status
这个grade变成了modified
从staged的状态退出了
那么这个时候
我再checkout
它就成为了上一次
还没有公开
没有东西就是说我是我改了
然后没公开
还是说我改了也没啥
你改了也没啥
怎样才跟我
改了
它还会
这种操作应该也是存在
如果你发现了
请你告诉我
简单评分之前覆盖掉就好
太简单了
然后刚才我们看一下
你再看一下status
第二行
有一个不一样的地方
它说
这个意思是说
我们现在的本地
比远程领先的一个层面
因为刚才我如果看git log的话
我们刚才是把这部分push上
但是这个是我们刚才加的
在这个状态下
我们可以看到
本地是多了一个commit
还没有push
就是说我们再处理一下
我们看status
这样的话
我们验证一下远端
我看到了
刚才的这个commit
以及今天其他的讲的部分
大家有什么疑问吗
刚才的问题就是说
如果我已经commit了
但是我commit了之后
但是我后悔了
我不想把它处理了
这该怎么办
这个操作其实比较复杂
那么同学们不掌握
也没有问题
今后会慢慢掌握
但我可以给大家演示一下
这个是怎么操作的
如果同学们觉得
今天如果学了太多的东西
觉得太多的话也可以不掌握
大家可以当做
看一个展示就可以
比如说
我真的把这个程序给它改坏了
然后我commit
我commit之后
我知道它坏了
对
比如说我这样把它commit上去
我新建了一个commit
然后这个时候我打log的时候
我看到一个 怎么会有这个东西
然后我git show 
看一下它都是有什么样的
commit的时候
发现这个地方好像打错了
但是我现在
不小心肯定能上来
我想把它扔掉
该怎么办
这个叫做rebase
什么叫rebase
我们看一下现在的
看一下现在是到
我有了这样一个
东西
有这样一个commit
还有这样一个commit
我现在觉得
这个地方我做的不对
我想把它扔掉
那么我想做的事情叫做rebase
什么叫rebase 
之前我们在讲
版本控制的时候
有一个叫做base
就是说之前的公共的版本
rebase就是说
我现在这里有这样一个commit
我想把我们可以理解为
在它之上
还有一个未来的一个指针
那么我想把未来的指针
把它的公共版本
向前移动一个位置
就是说移动到这个地方
所以说它的操作就是rebase
我们看一下rebase是怎么样的
这里面要解释的就稍微多了一些
rebase之后 -i
它的意思是
交互式地进行
那么head2
是说从未来的指针叫做HEAD
这是刚才你们讨论的是吧
也就是说它之前的两个
把它提交之前的两个这样的commit
大家可能没有看到
这里有一个
我最后一个
比较靠谱的commit在这儿
是吧
我们可以再试一下
如果我不想HEAD~2 HEAD~5
我们看到最近5个的
然后这时候我想把它
我想把这个不靠谱的
1386 
肯定会把它删掉
删掉的时候
或者是把它
就是在我的 
在我的编辑器里面都可以
用
其他的都可以
就把它删掉就行了
它其实就是把它
前面打了一个注释
其实就是把
把这个东西删掉了
我们
我看一下是那个
那么看一下git log
刚才的那个被删掉了
这样一个过程
这过程稍微复杂一点
但是今后同学们
需要的时候再用
还是没问题
我觉得有些同学
可能会继续往下问
我如果commit
之后
已经push了
但是我才想起来
我搞错了
该怎么办
再改过来再push
比如说改过来
可以用revert
git revert
它说之前把这个commit把它
把它反过来
比如说我们再做点坏事
你在这儿把它放进去
就这样的话
有一个不靠谱的commit
然后我们再
假如说已经push上去了
我把它push上去
这怎么变成了
我这个职业生涯的污点
我怎么做了一个这样的改动
回来赶紧把它我返回来怎么办
如果是最近的commit
就可以直接revert
但是我也可以这样
我不知道看一下commit
我会复制下来就可以
复制的时候
其实复制多少都行
只要保证第一个字母在
因为它是一个散列的
散列的标识
我复制一半也可以
它给我默认的
它给我默认的commit
消息就是说把它revert
然后把这个revert
做完之后我会发现
发了之后
然后再就是revert
把它撤销了
你记录还是要留下
这是一样的
我们可以
比如说现在这样的话
我这样revert过去了
就回去了
我想把我的污点彻底给它清掉
git rebase
然后我们把污点清掉
改正污点的行为也清掉
现在这个都没有是吧
可能我们强行的来
我们来处理一下啊
这样push是失败了
就这种情况下就是说
不允许这样
大家可以思考一下
为什么不允许这样的操作
就是说时间是有方向的
是吧
这个世界是有熵的
所以说
我们可以想象这样一个场景
我们有一个项目啊
我们有两个队员
它有这样一个commit
然后有这样一个commit
然后我发现有一个奇怪的commit
它在这个地方
都已经push上去了
然后我还有一个队友
我队友他已经push过了
我队友已经有
这个是远程我们我们叫做R
队友
我们叫友军
R friend
然后如果已经是这种情况
然后我们发现
这个是我职业的培养老板
比如说在远端的话
然后这个时候队友就会很奇怪
因为队友啊
然后我又把它加了一个别的
加了一个这样
我知道这个差分是这样的
每个差分都是依赖于指向前
一个的
是吧
那么查封在上面
那么我们队友看到了这个之后
他发现
对
这个地方要写成这个样子
我们队友感觉
非常地奇怪
感觉非常的迷惑
如果我用revert
其实我是给他加了一个
这里有一个奇怪的commit
然后我又加了一个反的commit
然后我又加了一个这个
这时候我的队友看到的是这种状态
那么我队友也可以pull过来一个
一个commit
这样队友
就会很舒服
可以直接把
可以直接同步过来
要不然队友看到一个
这样的状态
看到一个这样的状态
他会不会很难受
但是他已经看到了
那他就看到了是吧
可以这样比喻
但是朋友圈
它的先进性
是比较差很多的
不知道大家注没注意到
前年的 去年的年初
有过一个程序员的凶杀案
就是一个程序员到公司
把他的
把他的同事都杀掉了
然后
其中一个程序员
写了一个遗书
他写没写遗书
我记得
反正他平时比较
比较特别看不上他的同事
因为他同事经常会做这种操作
就是push上去一个比较奇怪的东西
然后又把它rebase掉了
然后又push到了远端
然后他就会经常出现这种情况
程序员就出现这种情况
也有方法可以做到
因为实际上这个项目
并没有自己做这件事情
反正是他歪死你
不要做这件事情
所以说之前他的同事
就经常干这种事情
然后那个程序员
就经常看到这种事情
然后今年每月
每次他都非常的不爽
积累了很多年
所以说同学们
在合作的时候
如果犯了错误
大家都犯了错误
如果犯了错误的话
就把它捋出来
是这样的
是最好的
如果就是它交互式的
假如第二个人他
就是说他干到一半干不下去了
假如说第一个人删了什么
第二个人能不能把那删的东西再
找回来
可以找出来
因为你在本地
因为这些分布式的版本控制系统
这样的话
比如说我
比如说是我的话
我其实是有整个历史的
全套的
全套的历史
那么比如说
他我的友军
把整个 
都把它毁毁灭了
那么即使他毁灭了
我在本地
就是有
这样一个完整的历史
不会
可能历史还能找到吗
不会的
历史还在
因为它最多会给你这些
反过来
这样的一个反过来
我可以回去
对你可以再倒回到这一点
或者到回到这一点
这些都是可以的
让他的本地删库跑路的人的
本地自己
也可以的
对
等于说没有删库这一块
对
所以说如果有控制的话
那么就很难删库跑路
大家可能问
为什么数据库
不用去把它控制起来
防止这种删库的行为
主要是因为数据库里面的
存储的空间
要求太大
如果数据量太大的话
用这样的体系
git的工具
还没有发展到
能够有效的
来重组这种超大的数据的
目前来讲
它存储程序
存储一些小的数据
绰绰有余
就是这样子
房子dd我们不用比较了
他就
那是不是因为他们搭档
所以就经常出现
并不是
是他搭档
经常把远端把它改把历史修改
导致他没有办法
跟搭档互相同步
我如果是自己看的话
我感觉
对
他可能没上过这个课
然后他觉得突然发现
可以修改历史
他就非常高兴的把历史修改了
把自己以前做的比较不好的
肯定能把它去掉
但是他队友就非常难受
没有办法再把它
我们不管
好
大家还有什么别的问题吗
咱们明天讲什么
明天
明天讲选择结构和循环结构
有作业
我们网络学堂的作业
提交不提交都没问题
最后我们算分会这个
上课都教会我们
就是说我知道
这个里面有一定的落实
我们现在还是在进度之上
所以说
如果大家学得很坏的话
就可以一直很友好
好
如果没有别的问题
我们可以下课
然后如果有
作业还有问题的同学
可以再在
