* 命令行
  我们已经接触了几个基本命令，
- ls :: 意为 “list structure”，列出当前文件夹下的所有文件。
- cd :: 意为 “change directory”，改变当前路径的位置，跳到另一个文件夹里。
- sudo :: 意为 “super user do”，用最高权限来执行指令。
- apt :: 缩写是“Advanced Package Tool”，是软件包管理器，有些默认的环境里面没有 python3，我们是通过它来安装上 python3。
- vi :: 是文本编辑器，这个编辑器不是当前流行的风格，但是非常强大，如果同学们有机会去深入学习这个编辑器，会发现它是完全是另外一个非常强大的世界。
- nano :: 也是文本编辑器，相比 vi 简单易上手。
- emacs :: 是我使用的文本编辑器，基于 Lisp 语言定制性极强。

  “现代”风格的文本编辑器至少有一个窗口，有菜单，有光标，但这是1990年代发展出来的。对 vi 和 nano 这样的风格，操作都通过 Ctrl-W，Ctrl-X 等快捷键完成，同学可能不太适应。nano 编辑器确实较简陋，只进行基本的操作，不是主力用编辑器。这些编辑器是应急使用，做一些快速简单的改动。每个人都会发展出自己的编辑器偏好，发展出自己最喜欢的工作方式，在学习的过程中要慢慢体会。vi 和 emacs 的学习曲线都比较陡峭。最开始的三天会感觉自己在和自己打架，但一个星期之后，就会发现与计算机的沟通有一个巨大的飞跃。


  POSIX 环境的设计理念是每一个命令都要完成且仅完成一件小事，这叫做“Do one thing, do it right”。这可以促进分工协作：用户可以把各类小巧的工具挑选出来，组合起来，应用各种各样的场景，有无限可能。连工具的设计者都没有办法预测出来用户究竟是怎么用他的命令的。

  无穷无尽的组合可能，会让大家在入门时迷茫。世界太大了，我们要挑选一条路会很难受，特别是选择较困患者。一旦能够入门，它将是威力巨大的一个技能。我们不要求每位同学都能够入门，大家掌握能够完成作业所需要的最小限度。感兴趣的同学可以选择一个命令环境的自学教程。注意国内教程和博客的水平水平参差不齐，经常在博客中会有很多错误的信息，大家在查资料时不要误入歧途。

  初学命令行时，会有非常多的不适应。为什么要学习 POSIX 这个“反直觉”的系统呢？在大规模数据处理和科学计算中，我们站在世界的前沿。并没有其他的开发者，给我们开发出现成的工具来完成科学任务。但是这个环境里面的很多小工具——连开发者也不知道能够被用在科学计算上——反而会更加有效地完成任务。如果一个学科发展出了成熟的工具，让我们可以点几下鼠标就可以制出一个完美的图，那么这个学科就已经发展成为工业级了。如果在实验室中有这样的程序，可能是学长给大家准备了这样的比较友好的界面，但是这些界面往往年久失修会有各种bug。掌握命令行的技能非常有用，它只是入门时有些痛苦，但适应之后，你会发现它成为思维的一部分。我非常希望能看到一部分同学能够理解这一点，今后掌握这些小工具创造出来前所未有的组合方式和操作方式。

  Git 给我们一个“时光机”，能够高效地记录自己过去的工作进展。同时在空间上，Git 辅助团队协作，可让大家互换差分，高效协同。这种合作模式促成和造就了全世界的大规模的项目的崛起。

** 图形界面
   Git的客户端中，也有许多图形界面的，但是都不大好用，常有玄学错误。而且很难修改和定制。目前命令行的Git是“最佳工具”。

** 加密
   很多同学是第一次手动操作加密通道，我们看到在网络空间人与人是如何互相验证和建立信任的。如果这些加密可信，我们就可以与队友和远程的服务器不断地交换差分。这部讲义就是这样协同创作的。

** 学习要领
   《实验物理的大数据方法》涉及的内容很杂，与物理学其它学科很不一样。碎片化的知识和技能不成体系，需要点滴的积累。可以用造房子来比喻，房子的最终成品有居住的功能，但是在准备材料时，要铁、砖、木头，这些东西之间好像没有什么联系。初学大数据方法时就大概处于这样一个阶段，头绪很多，但是所有材料都是马上都会用到的，并不是孤立的技能。
   
   当今特别强调可复现研究和开放科学，当发布一个论文时，数据和处理方法，图和表格的程序都应与论文一起发布在共享协作平台上，例如 GitHub。

* Python
  我们从 Python 程序的基本构建、变量和数据类型学起。Python 是一门解释型语言，相对于编译型语言如 C/C++ 它更容易调试。在解释型语言中，可以直接看变量结构是什么，而编译型的需要特别的调试器来进行。Python 的语法风格简单，没学过 Python 的人看了一遍 Python 程序，也能够大概地读懂。最近突然出现了这么多程序员，Python 的简单起了很大作用。Python 还可以直接调用很多其他的库。Fortran 是从 1960 年代开始的科学计算的基本语言。经过多年的积累，有大量优秀的一个科学数据处理、微分方程等工具库。Python，还可以调用从前的工具，大大地丰富了 Python 的科学计算能力。同时它也可以调用C/C++，R语言等。 Python 的特性不仅可以使它自己的功能增强，还可以使团队合作更加顺畅。

  Python 是一个通用的语言，不仅用于科学研究，在生活中使用得更多。Python 可用来生成和管理操作系统，如 Gentoo Portage 是我目前参与的项目。Python 还可以构建极简的网站服务器，如我们的大作业平台的评分系统由 Python 写成。Python 易于上手，易于开发，在实际中应用广泛。希望大家能够能够喜欢上python。

** 参考资料
   课上没有办法覆盖 Python 的方方面面，许多细节和新功能需要自学。Python 有很多学习资料，对自学非常友好。Python for Everybody 是一个简明通俗的入门教材，甚至适合没有高等教育基础的大众自学，书中非常友好地解释每一个程序元素背后的理念和目标。初学 Python 时，这本书读起来会很开心。编程基础比较强的同学，可以使用 https://learnxinyminutes.com/ 在一小时之内快速入门 Python。它把 Python 所有的例子都总结到了一个网页。同理，如果你在这门课上掌握了 Python，在研究中需要快速入门其它语言，也适合使用这个网站，通过例子把 Python 的技能迁移到其它语言。
   虽然教学的内容是借助 Python 跟大家表达的，在实际中不要把思想拘于 Python，世界很广阔。

** 运行环境
   注意 Python 存在两个版本主要版本，Python 2 和 Python 3。当 Python 发展到 Python 2时，已经是流行语言。开发者开始反思，总结了犯过的错误，希望在计划一个大版本进行改正。但这会导致现有的程序无法使用。怎么办呢？加了一个版本号，可执行程序的名字也不一样，叫 =python3= 。这样，新版程序用 =python3= 执行，旧版程序用 =python2= 执行。
   进入 Python 3 的环境，需要用 =python3= 命令。Python 有一个增强的互动环境，IPython。“I”的意思是 interactive。这个环境好在有智能补全，在交互性操作时比较友好。如果你的环境里没有 ipython3，可以使用 =apt install ipython3= 来安装。Python 的另一个运行方式是 Jupyter ，它由 IPython 发展而来，好处是可以在网页上来进行 Python 操作，交互性更强，可以规避掉命令行，适用于探索。坏处是网页操作没有优秀的编辑器可用，写大段程序不大顺手，并且网页环境的批量处理能力很弱。 
   Jupyter 使得 Python 的应用更广，有了更多的用户在网页上编程。这是个双刃剑，一方面基础很差的人，摸了几下 Jupyter 试了几种肤浅的操作，就以为自己学会了编程，到处招摇过市；另一方面，一个工具，可以受到全社会的关注，是非常荣耀的事。我推荐大家了解 Jupyter，把它与命令行组合使用，发挥最大的威力。但是它不能替代命令行工具。

** 基本算术运算
   :LOGBOOK:
   CLOCK: [2021-08-10 Tue 20:48]--[2021-08-10 Tue 23:00] =>  2:12
   CLOCK: [2021-08-10 Tue 15:59]--[2021-08-10 Tue 16:18] =>  0:19
   :END:

   可以做基本运算，还有一些其他的运算比如乘法。2的7次方是这样写，两个乘号。
   #+begin_src python :session op :exports both
2**7
   #+end_src

   #+RESULTS:
   : 128
   3/2是是严格的除法，
   #+begin_src python :session op :exports both
     3/2
   #+end_src

   #+RESULTS:
   : 1.5
   如果要整除的话写 3//2。
   #+begin_src python :session op :exports both
     3//2
   #+end_src

   #+RESULTS:
   : 1
   3%2 是取它的余数。
   
   #+begin_src python :session op :exports both
     3%2
   #+end_src

   #+RESULTS:
   : 1
   也可以使用高级功能，比如阶乘，阶乘需要使用使用 math 的库，要 =import math= 。3的阶乘是6，66的阶乘多大？
   #+begin_src python :session op :exports both
     import math
     math.factorial(66)
   #+end_src

   #+RESULTS:
   : 544344939077443064003729240247842752644293064388798874532860126869671081148416000000000000000

   这是 Python 的重要特点，整数是高精度的。在计算机的硬件里，每个数都要内存空间存储，我们如果学习C语言，需要知道有些整数用16比特，有些占用32比特，有些占用8比特，有的占用64比特。整数的范围是因定的。Python 又进行了一层抽象，使用软件实现了高精度的整数，在计算机可承受的范围内无上界。试试2的10000次方，
   #+begin_src python :session op :exports both
2**10000
   #+end_src

   #+RESULTS:
   : 19950631168807583848837421626835850838234968318861924548520089498529438830221946631919961684036194597899331129423209124271556491349413781117593785932096323957855730046793794526765246551266059895520550086918193311542508608460618104685509074866089624888090489894838009253941633257850621568309473902556912388065225096643874441046759871626985453222868538161694315775629640762836880760732228535091641476183956381458969463899410840960536267821064621427333394036525565649530603142680234969400335934316651459297773279665775606172582031407994198179607378245683762280037302885487251900834464581454650557929601414833921615734588139257095379769119277800826957735674444123062018757836325502728323789270710373802866393031428133241401624195671690574061419654342324638801248856147305207431992259611796250130992860241708340807605932320161268492288496255841312844061536738951487114256315111089745514203313820202931640957596464756010405845841566072044962867016515061920631004186422275908670900574606417856951911456055068251250406007519842261898059237118054444788072906395242548339221982707404473162376760846613033778706039803413197133493654622700563169937455508241780972810983291314403571877524768509857276937926433221599399876886660808368837838027643282775172273657572744784112294389733810861607423253291974813120197604178281965697475898164531258434135959862784130128185406283476649088690521047580882615823961985770122407044330583075869039319604603404973156583208672105913300903752823415539745394397715257455290510212310947321610753474825740775273986348298498340756937955646638621874569499279016572103701364433135817214311791398222983845847334440270964182851005072927748364550578634501100852987812389473928699540834346158807043959118985815145779177143619698728131459483783202081474982171858011389071228250905826817436220577475921417653715687725614904582904992461028630081535583308130101987675856234343538955409175623400844887526162643568648833519463720377293240094456246923254350400678027273837755376406726898636241037491410966718557050759098100246789880178271925953381282421954028302759408448955014676668389697996886241636313376393903373455801407636741877711055384225739499110186468219696581651485130494222369947714763069155468217682876200362777257723781365331611196811280792669481887201298643660768551639860534602297871557517947385246369446923087894265948217008051120322365496288169035739121368338393591756418733850510970271613915439590991598154654417336311656936031122249937969999226781732358023111862644575299135758175008199839236284615249881088960232244362173771618086357015468484058622329792853875623486556440536962622018963571028812361567512543338303270029097668650568557157505516727518899194129711337690149916181315171544007728650573189557450920330185304847113818315407324053319038462084036421763703911550639789000742853672196280903477974533320468368795868580237952218629120080742819551317948157624448298518461509704888027274721574688131594750409732115080498190455803416826949787141316063210686391511681774304792596709376

   这是 Python 的一大特色，它样做需要经过许多诸如内存判断，用多少内存，数量还会变化，多重判断会降低效率。但是现在计算机硬件水平，用效率损失来换取方便的接口是值得的。这也是本课程的基本价值观：如果能够节省人类的时间，不惜浪费计算机的时间。这与计算机专业研究有区别：计算机研究的目标，是让它更快，算法更巧妙，效率更高。

   整除有一些基本的约定，看几个例子
   #+begin_src python :session ob :export both
     -5 // -3
   #+end_src

   #+RESULTS:
   : 1

   #+begin_src python :session ob :export both
     -5 // 3
   #+end_src

   #+RESULTS:
   : -2
   往下面降。要注意，有些语言不是这样的约定，而是按照绝对值最小的方向去去降，那么-5整除3会给出-1。
   #+begin_src python :session ob :export both
     (-5 // 3) * 3 + (-5 % 3) == -5
   #+end_src

   #+RESULTS:
   : True
   
   除号和取余号也可以用在浮点数上。

** 布尔运算
   :LOGBOOK:
   CLOCK: [2021-08-11 Wed 20:34]--[2021-08-11 Wed 21:28] =>  0:54
   :END:
   布尔运算得到“真”“True”或者“假”“False”，是数理逻辑的范畴。否命题
   
   #+begin_src python :session ob :export both
     not True
   #+end_src

   #+RESULTS:
   : False

   #+begin_src python :session ob :export both
     not False
   #+end_src

   #+RESULTS:
   : True
   
   =and= 和 =or= 和数理逻辑的“和”跟“或”的定义是一样的。它的内部表示和其他语言很类似， =True= 和 =False= 不是全新的数据类型，它内部以数字形式存储。
   #+begin_src python :session ob :export both
     True + True
   #+end_src

   #+RESULTS:
   : 2
   严格的数理逻辑中，只是01运算，组成的加法群中， =True + True= 应该还是 =True= 。但是Python 中结果变成了 2。

   #+begin_src python :session ob :export both
     2 and True
   #+end_src

   #+RESULTS:
   : True

   此时 2 与 1 一样，都被当作 =True= 处理，即非零整数被在逻辑运算中是一个等价类。
   
   Python 的设计符合直觉和数理逻辑的定义。如果在布尔运算中用乘法也是自恰的，因为 =True= 是非零， =False= 是 0。这可以帮助我们理解 =True= 和 =False= 的实现。

   实际应用中 =True= 和 =False= 源于条件判断，如等号。“=”已经被赋值占用了，条件判断用“==”
   #+begin_src python :session ob :export both
     1==1
   #+end_src

   #+RESULTS:
   : True
   #+begin_src python :session ob :export both
     1==2
   #+end_src

   #+RESULTS:
   : False
   
   “不等于”在python里边是“!=”。

** 数据类型
   Python 有三个基本数据类型：

   - 整型 :: 我们刚看到的精度无限的整数；
   - 浮点型 :: 精度是有限的，常见的是64位高精度；
   - 字符串 :: 单个字符也是字符串，这与 C 语言不同。字符串拥有无限长度，在软件上把它进行了便利的实现和抽象。

   #+begin_src python :session ob :export both
     type(1)
   #+end_src

   #+RESULTS:
   : <class 'int'>

   #+begin_src python :session ob :export both
     type(1.5)
   #+end_src

   #+RESULTS:
   : <class 'float'>

   #+begin_src python :session ob :export both
     "今天" + "下雨了"
   #+end_src

   #+RESULTS:
   : 今天下雨了

   字符串用单引号和双引号都可以，一个好处是字符串里要输入一个单引号，可用双引号来引用。
   #+begin_src python :session ob :export both
     "'"
   #+end_src

   #+RESULTS:
   : '
   #+begin_src python :session ob :export both
     '"'
   #+end_src   

   #+RESULTS:
   : "
   这是双引号。 Python 3 所有的国际语言的符号都可内嵌到语言里，字符串可以直接使用汉字。相对于更基础的语言如C/C++，可以给我们非常大的便利。大家已经约定良好的处理字符串的方法都已经被 Python 作为默认功能。要入门程序语言，我们要打印“Hello World！” 向前人致敬。
   #+begin_src python :session ob :results output :export both
     print("Hello, world!")
   #+end_src

   #+RESULTS:
   : Hello, world!
   Print 是 Python 的一个函数，里面可加一个字符串。

** 变量
   Python 的变量与数学的含义类似，用以指代一个任何对象，例如字符串，
   #+begin_src python :session ob :results output :export both
     message = "This is an new era. 新时代"
     print(message)
   #+end_src

   #+RESULTS:
   : This is an new era. 新时代

   那么随后就可以用变量代替字符串。Python 的一大的特点是变量没有类型。我们可以看到，

   #+begin_src python :session ob :results output :export both
     message = 3840752916
     print(message)
   #+end_src

   #+RESULTS:
   : 3840752916

   =message= 这个变量既可以是字符串，也可以是整数。 Python 是无类型语言，这是很强的假设。如果语言的变量没有类型，那么它在运行中每次调用 =message= 时，都要检查它到底是什么类型。可以想象这样做需要额外的步骤调取内部的函数和库，Python 损失了很多效率。但是，我们喜欢！因为人类的脑子里也不区分整型、浮点型和字符串。Python 用它上层的软件库，给人带来了很多的便利，符合直觉是 Python 语言的一大特点。在做科学计算时，这个问题没那么简单了。学习 Numpy 时我们将看到，无类型变量的效率太低，我们只能再放弃一点便利，为了性能规定变量类型。
   
   变量本身也可以赋值给另一个变量，
   #+begin_src python :session ob :results output :export both
     m = message
     print(m)
   #+end_src

   #+RESULTS:
   : 3840752916

   =input()= 与 =print()= 对应，可以用来输入变量。例如：
   #+begin_src python :session ob :export both
     # q = input("Enter anything: ") # 输入 47042
     q = "47042" # 结果
     type(q)
   #+end_src

   #+RESULTS:
   : <class 'str'>
   注意得到的变量类型是字符串，如果需要数字，需要转换成整型。

   #+begin_src python :session ob :export both
     type(int(q))
   #+end_src

   #+RESULTS:
   : <class 'int'>

** 标准输入
   =print= 可以把信息打到标准输出，也就是屏幕上。那么如何从外界输入给程序信息呢？接下来学习输出变量的命令 =input= 。

   #+name: number-input
   #+begin_example 
     5
   #+end_example
   
   #+begin_src python :session :export both :stdin number-input
     x = input()
   #+end_src

   #+RESULTS:

   接到提示把数字 "5" 输入进来，赋值给了 =x= 。此时 =x= 是 "5" 字符串。我想输入数字，这就需要转换它，

** 行编辑命令
   不论是在 Python 的交互环境，还是在 shell 中，都可以使用“行编辑”命令来辅助输入。例如，“Ctrl-R” 用来搜索之前的指令。

   比如我们玩了一会 Unicode，然后我忘了。那么我按Ctrl-R向上搜索，Ctrl-S 就是向后搜索，Ctrl-I 是向前搜索。
所以说我们如果在 python 的环境里输入了比较多的命令之后，想查询先前的命令就可以通过 Ctrl-R 和 Ctrl-S。 
那么同样的道理，在我们环境的约定中，如果我们在命令行里面输入一些指令之后，同样可以用 Ctrl-R 和 Ctrl-S 来进行搜索。这就避免了我们一直在键入 ls。

这样就可以使得我们程序跟外界有一个交互。输入一个这样的字母，这个信息就赋予给了字母。它也可以是计算机来处理
或其他程序的接口。如果是其他程序的接口，很多程序前一个程序的输入，就可以前一程序的输出就是可能后一个程序的输入
这样就可以链接起来。


下面我和大家一起复习一下上一次的作业的步骤。

我现在用 nano 打开一个新的文档（新建），首先我将第一个 input 赋予变量 a，第二个 input 赋予变量 b。
如果 a 是一个字符串且 b 也是一个字符串，那么 a 加 b 会给出两个字符串的连接形成的字符串。如果我们把它们转化成整型的，它就可以进行加法运算。可以看到我们的得分是100分。

下一步对这个文档进行 git add 操作。此时 git diff 可以显示做了哪些改动（截止上次？？？）。比如说这里原来是一个空文件，只有之前助教同学给的提示，在这里加了两个变量。

另外我们用 git status 可以看到这个被改了。在这种情况下，就可以把改动累加起来。我们再看一下 status，
我刚才add了之后
它知道
现在是modified
我add了之后 把文件做了一个标记
标记为
它将用于commit
所以我们看它其实是已经
慢一点
慢一点
又不知不觉的
做的比较快一点
我重新来一遍
这个git diff
首先我拿git diff看了一下
我做了一下对应的改动
那么最后我们打git diff的话
就可以看到
我对这个文件
进行了什么样的整改
我们看到
加了输入a然后输入b
然后和print
这个部分
这个更改恰好是我们做的
所以我觉得很满意
这更改完了
所以我决定把这个更改
commit上去
commit之前
我先要给它加一个标记
说我准备提交这个文件
那么我加了这个标记
就是add
我刚才改的
是这里
所以把
就是说
我 add 文件的意思是说
刚才我们讲到的 git 有三个阶段
刚才同学的问题
就是
说到底什么是做标记
我们再来回顾一下
因为这个工具
大家第一次使用
所以很多概念还不太清楚
所以一旦我操作的时候
大家也跟不上了
一定要提问
所以谢谢这位同学
刚才我可能讲的太快
那么一会儿上课回来
我给大家重新讲一下
这个 git 的 staged
好
我们先下课休息一会
好
我们进行上课了
咱们先讲一会
刚才有同学感觉
有点奇怪
我可能两个阶段
就能把这个问题搞定了
是吧
为什么要add
你比如说我现在
有了一个
提交之后
我做了一些修改
修改之后
我造一个新的提交就完事了
为什么还要add的一步做一个标记
然后再进行提交
我们先回顾一下
add是什么意思
我们先把这个项目
add的意思是
最开始它是一个提交的状态
然后我们进行了修改之后
变成了
已修改
已修改状态之后
有一个叫做staged
这个staged
中间态
没有一个统一的翻译
你就要打一个标签
就是说当我们把这个文件
打一个标签之后
那么staged的部分
在下一次肯定就会被交上
同学们不太理解说
为什么多出来的这样的一个staged
那么先打标签
然后再提交
我能不能直接提交
直接提交也是有一个方法的
比如说
我刚才如果不add的话
直接commit
那么这个时候会出现什么情况呢
那也就是说我
比如说我们仔细读一下
但是他重要的一部分就是说
no change added to commit
也就是说
我还没有add文件
它就把这个文件
放到即将commit 
这个队列里面
就是说我还没有给它打标签
让它commit
所以说它觉得没有东西
可以
这会出现这个情况
那么其实就是仁者见仁
智者见智
有些同学可能会喜欢
我就是忽略这个步骤
那么这个时候可以加一个参数
叫做-a
我们先看一下
这个-a是什么意思
昨天我们讲到
如果要看文件里边的
它的文档的话
可以用这个man
看它的文档
那么如果我们执行man git commit
我们看到这个屏幕
是什么意思
我们小抄里边不知道有没有
比如说应该是最全的
你看一下-a是什么意思
实际上来讲
如果我们忘了
commit都有什么参数
我们就可以通过这种方式来
我刚才在这儿
那么-a就是
也就是说
如果-a的话
可以跳过这个staged的过程
可以跳过打标签的过程
我们把所有的可以改动的文件
都提交成一个新的改动
它还提醒我们说
如果有新的文件
那么它不会被添加
那么刚才的这种情况
我们查了文档之后
我们知道 
我们可以看到
如果我们commit
好
可以了
就出来了一个编辑器
-m就是直接输入我们的
-m可以查一下
我们来查一下什么是 -m
-m在这
是吧
-m就是直接message
或者是 --message
也就是说之前我们在commit这个
时候
它会出一个窗口告诉我们，让我们备注 commit 所做的修改。但是如果我们想都在命令行里完成的话，我们就可以直接跟一个 -m。然后把要描述的话
我们看这样的话
当然不能这样说
这样说是要被扣分的
我先不这样输入
我们来展示一下-m是什么
刚才我没有输入
没有输入任何的注释
所以说它说因为我的
注释
是空的
所以它没有commit
所以我刚才的命令
我如果按一下上的话
就调出来上一个命令
刚才我直接-m的话
这个是
这里头我就用了引号
会更稳一些
这样就没有弹出来
在刚才的编辑器
直接以这个为提交的push给它
你们如果看
我们来看一下
整个我们改动的
这些差分的历史的话
就这一块
刚才我做的
这样就完成了之后
我们就可以把它push
 
我们有很多方法可以查看提交的注释。比如，查阅 git log，这里记录了改变的历史。在团队合作的时候，可以查询它的整个历史，并且对每一次修改都可以有非常明确的追溯
 
那么我们还有一个遗留的问题：为什么要三个阶段？而不是两个阶段就完事了。用 -a 的方法可以把三个阶段变成两个阶段。那么为什么要有三个阶段呢？比如说，我做一个改动：比如，这一行太长了，可读性比较差，我们想先把可以转化成多行。我们再看一下这个数据，又覆盖了原来的这个变量，那么，b 也覆盖原来的变量。这样一个过程，那么这个程序我改完了。看了一下，我比较满意。与此同时，这个时候我想看一下作业里边图形统计。这个时候我们 git status 的时候有两个文件被改。

这时候，助教过来了，发现我改的是一个违规的行为 git commit -a -m 。有的时候我可能改了之后，我只是探索一下评分。
所以说有的时候我改完就忘改回去了。
这时候我如果我没注意的话，我就直接 git commit -a，那么就把评估程序给改了。如果这样的话是要被扣分的。所以说这个时候怎么办，我想只把部分提交上去。这个时候三个阶段的作用就会显现出来。比如说，我只是想把它作为下一个提交，而另一部分不想作为下一个提交。如果我 git add 的话，我就只 add 这一个就行。我再看一下这个 status， 能够看到现在我们在 master 这个 branch 上。这一部分的改动，已经被加了标签，马上就要被提交了。但是下一部分就我没有 add 它，没有把它作为下一步要提交的备选。那么这部分它只是仍然是被修改的状态，它并不会被提交。那么我们来看一下，如果那个时候我们，不要再加 a ，commit 也追加 m。我们再看这个 log，
其实就是啊这样的一个log
对吧
有这样一个
加上这样一个提交
那么我看一下
提交有哪些改动呢
这个时候有另一个命令叫做 git show，它默认会把之前我们做的改动？？？。
看一下到底改了什么
我再慢慢的打一遍
git show
然后我们看一下这是什么
这是我刚才做的改动
然后我们把注释需要
我刚才对这个 grade 的改动
并没有放到差分
我们看一下
现在如果这个 git status
我发现
上一个文件已经进入了
那个文件已经进入了 unmodified 的状态，已经从打了标签的状态变成了 unmodified。
但是刚才改的grade的部分，还是可以的。
所以说在这种情况下，我们就可以无意中做了很多修改
之后我们再把这些修改分成各个部分做成逻辑上相对独立的
这样对我们自己未来经过了1年，5年，10年之后，回过头来再看，就会看到我们提交的历史，更加有逻辑性。
并且如果有队友的话，队友也比较容易理解到底做了什么样的工作。
还有grade 我们看一下git
我看一下 grade 我们到底对它做了什么样的
checkout 
checkout是什么意思
从我现在已经commit的一个改动里边，把最新的版本拿出来，覆盖我现在有一些。这是一个很危险的操作。
也就是说我之前没有提交的改动就都消失了。所以说执行这个命令的时候，一定要非常注意，这可能是你一下午或者是一天的心血。如果一下子 checkout 的话，可能就是被覆盖了。这件事情我是做过的，当时确实是痛不欲生。

覆盖之后，我们即使我把它已经 add 了
这个还可以覆盖吗
好问题
我也不知道
我们可以试一下
我们先覆盖一下
先给大家展示一下
覆盖然后git diff
然后就没了
我刚才修改就没了
那么我这次做一个更加
略微超额的操作
就是说
刚才同学的
提出了疑问
就是说如果我 add 之后
我这个checkout它
能不能
我们来试一下
它不会覆盖
我add之后 
我后悔了
怎么办呢
我看到我把它改成100分
我非常后悔
那么我就这样
又有一个新的命令
大家可以参考一下小抄
然后参考一下
网络学堂里面的
教程
这样reset之后
我们看到 
刚才是加了标签之后
它叫做staged
这个是unstaged
就是把这个stage取消了
这个时候
我们再看status
这个grade变成了modified
从staged的状态退出了
那么这个时候
我再checkout
它就成为了上一次
还没有公开
没有东西就是说我是我改了
然后没公开
还是说我改了也没啥
你改了也没啥
怎样才跟我
改了
它还会
这种操作应该也是存在
如果你发现了
请你告诉我
简单评分之前覆盖掉就好
太简单了
然后刚才我们看一下
你再看一下status
第二行
有一个不一样的地方
它说
这个意思是说
我们现在的本地，比远程领先的一个层面。因为刚才我如果看 git log 的话，我们刚才是把这部分 push 上，但是这个是我们刚才加的在这个状态下。我们可以看到，本地是多了一个 commit，还没有 push。就是说我们再处理一下，我们看 status，我们验证一下远端，看到了刚才的这个 commit，以及今天其他的讲的部分。


如果我已经commit了，但是我 commit 了之后我后悔了，不想把它处理了。这该怎么办？这个操作其实比较复杂。
比如我真的把这个程序给它改坏了，然后我 commit， commit 之后，我知道它坏了。这个时候我打 log 的时候，我看到一个怎么会有这个东西。然后我 git show 看一下它都是有什么样的 commit 的时候，发现这个地方好像打错了。
但是我现在想把它扔掉。这是我们需要一个新的命令，rebase。什么叫 rebase？之前我们在讲版本控制的时候，有一个叫做 base，即公共的版本，rebase 就是说现在这里有这样一个 commit，我想把我们可以理解为在它之上，还有一个未来的一个指针，那么我想把未来的指针，在它的公共版本向前移动一个位置，移动到这个地方。
这样的的操作就是 rebase。
我们看一下现在执行 rebase 是怎么样的，rebase 之后 -i，它的意思是交互式地进行。
那么head2
是说从未来的指针叫做 HEAD
这是刚才你们讨论的是吧
也就是说它之前的两个
把它提交之前的两个这样的commit
大家可能没有看到
这里有一个
我最后一个
比较靠谱的commit在这儿
是吧
我们可以再试一下
如果我不想HEAD~2 HEAD~5
我们看到最近5个的
然后这时候我想把它
我想把这个不靠谱的
1386 
肯定会把它删掉
删掉的时候
或者是把它
就是在我的 
在我的编辑器里面都可以
用
其他的都可以
就把它删掉就行了
它其实就是把它
前面打了一个注释
其实就是把
把这个东西删掉了
我们
我看一下是那个
那么看一下git log
刚才的那个被删掉了
这样一个过程
这过程稍微复杂一点
但是今后同学们
需要的时候再用
还是没问题

有些同学可能会继续往下问，如果 commit 之后已经 push 了，但是我才想起来我搞错了，该怎么办。再改过来再 push，比如说改过来可以用 git revert。比如说我们再做点坏事，你在这儿把它（？？）放进去，就这样的话，有一个不靠谱的 commit。然后再 push 上去了，这简直是我职业生涯的污点，我怎么做了一个这样的改动，回来赶紧把它我返回来怎么办 T_T 如果是最近的 commit，就可以直接 revert。但是我也可以这样，我不知道看一下 commit，我会复制下来就可以，复制的时候其实复制多少都行
只要保证第一个字母在，因为它是一个散列的的标识，我复制一半也可以。给我默认的 commit 消息就是说把它 revert。 把这个 revert 做完之后我会发现，把它撤销了你记录还是要留下？？？

我们可以比如说现在这样的话我这样 revert 过去了，就回去了，我想把我的污点彻底给它清掉。用 git rebase
我们把污点清掉，连同改正污点的行为也清掉。我们来 push 一下，可是这样 push 失败了。就这种情况下就是说不允许这样。
大家可以思考一下为什么不允许这样的操作。时间是有方向的，这个世界是有熵的。我们可以想象这样一个场景：我们有一个项目，两个队员，有这样一个 commit，还有这样一个 commit，还发现有一个奇怪的 commit，都已经push上去了。然后远程队友也已经 push过了。

比如说在远端的话队友就觉得会很奇怪，因为队友看到我又把它加了一个别的，加了一个这样。我知道这个差分是这样的，每个差分都是依赖于指向前一个的。那么我们队友看到了这个之后，他发现这个地方要写成这个样子非常地奇怪，非常的迷惑。如果我用 revert，其实我是给他加了一个奇怪的 commit，以及一个反的 commit，然后我又加了一个这个。这时候我的队友看到的是这种状态，那么我队友也可以 pull 过来一个
一个 commit。这样队友可以直接同步过来。

** 汇报问题
   #+begin_src python :session ob :export both
     ipnut()
   #+end_src

   #+RESULTS:

   我们在操作计算机时，会经常看到英文的出错信息。遇到问题不要慌，仔细看一下 =Trackback= 上的提示。
   #+begin_example
     Traceback (most recent call last):
       File "<stdin>", line 1, in <module>
     NameError: name 'ipnut' is not defined
   #+end_example
   我们处于交互模式，所以是 =File "<stdin>"= ，表示是从标准输入（standard input，缩写为 stdin）执行的程序。接下来显示 =NameError= ，告诉我们单词 "input" 拼错了。 初学者很容易见到长串的出错信息就感觉就立刻焦虑，想要赶紧切换方法。盲目尝试了其他方法，又发现其它的错误信息。

   遇到出错信息怎么办？求助时，若只讲“报错啦”，他人会追问具体报出什么出错信息。解决问题的要点都在错误信息本身。因此要非常重视这些信息，初次见到它未必容易理解，比如涉及了像 =Traceback= 和 =stdin= 这样的生词和术语。克服了它们，我们积累了经验就能够迅速定位到问题的关键。

